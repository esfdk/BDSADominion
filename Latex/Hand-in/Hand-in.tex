\documentclass[12pt,a4paper,notitlepage]{article}
\usepackage[latin1]{inputenc}
\usepackage[english]{babel}
\usepackage{graphicx}
\usepackage{fullpage}
\usepackage{fancyhdr}
\usepackage[final]{pdfpages}
\usepackage[font=sl]{caption}
\usepackage{listings}
\usepackage{fancyvrb }
\usepackage{hyperref}
\hypersetup{
    colorlinks,%
    citecolor=black,%
    filecolor=black,%
    linkcolor=black,%
    urlcolor=black
}

\pagestyle{fancy}
\fancyhead{}
\cfoot{\thepage\ of 53}
\renewcommand{\headrulewidth}{0.0pt}
\fancypagestyle{plain}{
\fancyhf{}
\cfoot{\thepage\ of 53}
}

\setlength{\parindent}{0pt}
\setlength{\parskip}{1.8ex plus 0.5ex minus 0.2ex}

\title{\huge{Dominion}\\
\large{Analysis, Design and Software Architecture}
}
\author{
Jakob Melnyk, jmel@itu.dk\\
Christian Jensen, chrj@itu.dk\\
Frederik Lysgaard, frly@itu.dk
}
\date{December 14th, 2011}
\begin{document}
\maketitle
\vfill
\section*{Abstract}
This project is about a virtual representation of the card game Dominion in C\#. Dominion is a turn-based, deck-building game, where the objective is to gather more points than the other players. The game is played by 2 - 4 players.
\clearpage
\tableofcontents
\pagebreak
\section{Requirements}
\subsection{Mandatory}
Must be able to play a full game of Dominion
\begin{itemize}
\item Must support 2 players in Hot-Seat configuration
\item At least 10 Kingdom cards must work
\item The game must be playable in a Picture-based GUI
\end{itemize}
\subsection{Secondary}
High priority
\begin{itemize}
\item Be able to play the game with 3 or more players
\item Be able to use at least 20 Kingdom cards
\item Be able to select Game Mode
\begin{itemize}
\item Be able to play 'First Game' Card-set
\item Be able to play with 10 randomly select Kingdom cards
\end{itemize}
\item Be able to see all Available Kingdom cards without scrolling
\end{itemize}
Medium priority
\begin{itemize}
\item Be able to view a Tooltip when mousing over any Card in the game
\item Be able to play the game over LAN
\item Be able to use all Kingdom cards (from the original version of the game)
\item Be able to play all the Card-sets defined in the original rules
\end{itemize}
Low priority
\begin{itemize}
\item Be able to Draft Kingdom cards
\item Be able to play the game over the Internet
\item Be able to select different screensizes
\item Be able to play in fullscreen
\item Be able to create a User, that is saved across multiple games, with the following information:
\begin{itemize}
\item Statistics
\item Options (if any)
\item Achievements (if implemented)
\end{itemize}
\item Be able to support Extensions of the basic game
\item Implement Achievements for funny and/or hard accomplishments
\end{itemize}
\pagebreak
\section{Overview}
\subsection{About}
This project is about our virtual representation of the card game Dominion. Dominion is a turn-based, deck-building game. The objective of the game is to use Action cards to improve your chances or damage the opponent players and using Treasure cards to buy more powerful Action/Treasure/Victory cards to gain the upper hand. 

Requirements that are fulfilled:
\begin{itemize}
\item All three mandatory requirements.
\item Able to play with three or four players.
\item Able to play the game over LAN.
\end{itemize}
Section \ref{sec:Examp} on page \pageref{sec:Examp} walks through it in more detail.

\subsection{Team members}
Frederik Lysgaard is the guy responsible for the design of our graphical interface. He designed the interface using XNA, which he learned during the project. He is also the best Dominion player in our group. Because of this, he knows a lot of the usual strategies and is our general "go-to" guy when it comes to the tactics of the game.

Christian 'Troy' Jensen is our networking guy. He set up all of the networking with a server-client architecture and made it interface well with Control. He also did the proxy interface between the GUI and Control, so that the GUI could be replaced and Control would never know. 

Jakob Melnyk is responsible for modeling the state of the game and the communication between Control and the Model (Gamestate), Control and GUI (the proxy-interface that Christian developed) and between Control and some parts of the network interface. Jakob is also the "version-control-guy", the person with the final word in discussions and the general log-keeper.

\subsection{Architecture}
We have used a Model-View-Control architecture to do a heavy separation of concerns in terms of the GUI, server, model and game logic. We planned on having a static model outside of the controller to contain the game logic (in terms of card attributes), but we decided to do it more simply in the controller and then focus on getting networking in the game. 

The networking is done with a server-client architecture where the server has a number of clients and one or more of these clients can be itself. Currently we have only tested it on the server's local machine and on a LAN with the server. It should be possible to play over the Internet, but we have not tested it to any degree and as such cannot make any promises that it will work.

In the "Related Documents/Dependency Graphs" we have included dependency graphs for the Card Inheritance hierarchy, Control's dependencies and Gamestate's dependencies.

\subsection{Known bugs}
\begin{itemize}
\item It is very hard to click on the bottommost field in the Supply in the GUI.
\item Sometimes a player will not be shown on the GUI at the end of the game whether he has won or lost the game. It is however shown in the console.
\item While the hand can contain more than seven cards, it is not possible to see and use cards beyond the seventh card in the hand.
\item If more than nine cards are played in any given turn, the tenth card and beyond will be drawn outside of the game window.
\item The number of cards in the supply does not vary according to how many players are in the game.
\end{itemize}

\subsection{Validation}
\subsubsection{Code Contracts and Pex}
We have been debugging with Code Contracts enabled, but we do not have them enabled for the released version. We used to not only to have contracts on our classes, but also so that we could use Pex to generate some unit tests for us. The main amount of the contracts are in the Gamestate namespace, but there are a few contracts elsewhere in our project.

Pex could not generate as many unit tests as we would have liked within the time we had, but it covers about 8\% of our code on its own. dotCover html report file of only the Pex tests can be found in "BDSADominion/dotCover Coverage Runs/Pex solitaire snap.html".

\subsubsection{Screencast}
We did a screencast of ourselves playing a couple of turns at the start of a game and of a player winning the game. These are called "BDSADominion - Screencast pt 1" and "BDSADominion - Screencast pt 2", respectively. These can be found in "Related Documents/DominionScreencast".

Because we play a few rounds and the game continues doing the same turn-based play, we feel that showing that a couple of turns work can be used as validation for the functionality of our game. Because we also show that a game can be won in the second screencast, we have shown that the game can end.

\subsubsection{Code Coverage of a game}
While we have not done scenarios, we have instead played the game many times and so, in a sense, have validated it to some degree.

Besides the Pex code coverage, we also ran dotCover with "Cover Startup Project". This checks how much of the code is covered during the run of the Project's Start. 

The most code coverage we got in any single run using this way of covering code was Christian running his game as a server and then joining another client on his server from his own machine. The results of this can be see in "BDSADominion/dotCover Coverage Runs/TroyServerRun1.html". This report covered a lot of the code from the Connection and Server classes. 

Another report merged from a solo player running the game "BDSADominion/dotCover Coverage Runs/Merge\textunderscore Report.html", the Pex results and the game being run as a client on another computer, did not really do so well in covering the network area, but covered the other parts of the application better than "TroyServerRun1" did. We should be able to reach at least 85\% code coverage by our calculations.

\subsection{Code Metrics}
We did Visual Studio's code metrics on our project and the exported CodeMetrics.xlsx (Excel file) can be found in "Related Documents".
Of note in the code metrics is our Player class with the three methods with the highest cyclomatic complexity in the project (53, 48, 43).  These are methods for adding and removing cards from a Player, which in turn make them heavy on contracts, which could explain the cyclomatic complexity.

\subsection{Notes}
\begin{itemize}
\item Given more time, we would definitely have used BON to better describe our architecture.
\item We could have added more and better contracts, given more time. Especially invariants could have been done in more classes.
\item We could probably have done without the inheritance as it looks now, because we never use the fact that something is a specific card, only ever its type (Action, Treasure, etc.)
\end{itemize}

\pagebreak
\include{Subfiles/Dictionary}
\pagebreak
\include{Subfiles/Example}
\pagebreak
\include{Subfiles/Revision_History}
\include{Production/System_Analysis}
\include{Production/System_Design}
\include{Production/System_Production}
\include{Production/BON}
\begin{thebibliography}{9}
\bibitem{dominionRio} http://www.riograndegames.com/games.html?id=278
\bibitem{dominionRules} http://www.riograndegames.com/uploads/Game/Game\_278\_gameRules.pdf
\bibitem{shen} Simon Henriksen shen{\makeatletter @\makeatother}itu.dk
\end{thebibliography}
\end{document}
