\subsection{System design}
\subsubsection{General}
We decided to use an MVC pattern for our overall structure, because we felt we could seperate the model (the Gamestate), the View (GUI) and Control (Game Logic and more). We also use a Client-Server architecture to do the network communcation. We have all used BON to describe most of our architecture.

\subsubsection{GUI}
\subparagraph{Frederik Lysgaard}
In terms of system design, there isn't really much to say to the GUI part since none of us knew the XNA framework, and therefore didn't have any knowledge of the limitations and benefits.
This led to a very ad hoc way of designing the GUI system, for the first draft I used my exstensive knowledge of the game to try and get a overview of the components needed to properly display and play a game of Dominion. 
This resulted in the basic design for the GUI, but since I was still a newbeginner to XNA, this led to a design with almost all the right classes but with some strange inheritance, all in all it felt weird which made me study XNA some more, and after having used some days getting familiar with the framework I came up with the second and final draft.

Even though this was the final draft, it was far from perfect, I would for example if had, had more time with XNA before the project suggested some inheritance between the zones since they all is made from the same sprite "template". So to summarize there wasn't really any general battle plan for the GUI system design at the start of the project, which was a challenge, that taught me one thing, if you know you're going to work in a new framework, learn it beforehand.

\subsubsection{Client \& Server and Control (Server and start-up parts)}
\subparagraph{Christian Jensen}
When we set out to make Dominion, we knew that network should not be a mandatory requirement, yet here we are with it.
There are several reasons for this, such as that even to be moderately able to play the game, multiple computers should be involved.
However, on a more practical level, I lacked an area of responsibility after we decided to couple the Control and GameState tighter, and network seemed an obvious idea.

I had one problem however: I had little to no idea about how to build a network system that would be appropriate for the project (nor did any of my teammates), both in terms of C\# and networks in general. 
This is the primary reason why I could not sit down and design a network off my head. I needed to study the options first.

I did what any respectable coder would do; I searched the internet to see if somebody already had coded a solution. 
I came by several solutions but they were either not doing what we needed or was too complex.
An answer presented itself. I knew of a guy who is in a group doing a seperate project and who is a wiz at networks in general (Simon Henriksen, shen@itu.dk) and the network part for their project (Descent) was quite similar to what we needed. 
We had several inter-group meetings during the project period with his group and a third (Magic the Gathering) and I asked him to help me understand several concept related to networks and how C\# could use them.

He often referenced to his own implementation and just like using an Internet example to provide the basis for an implementation, he graciously allowed me to use his implementation as the basis for mine.
I am not peticularly proud of this point, but my options was either use some structure I didn't really understand or use this, which I will claim to have grasped quite well.

\subsubsection{Gamestate and Control (Game Logic)}
\subparagraph{Jakob Melnyk}
At first we decided to split Control, the static game logic and the dynamic game model into three different pieces of the architecture, but after a lot of thought and effort went into how to create the Game Logic (or more specifically, the card rules) as a seperate entity, we could not come up with way to do it that did not seem very akward. Instead we decided to let the Control class handle what happens when, for example, a specific card is played in the game.

So instead of both a dynamic and a static model as two seperate entities, we now had the dynamic model and the Control class making the magic happen. Whilst Control seems a little akward and cluttered at the moment, we feel we have really achieved what we wanted to with the Model-View-Control.

Most of the BON I made for the Gamestate was done in a way so that it would be easy for an outside source to access what he needed to know to make the dynamic model change. However, instead of making a very vast interface for all the different collections, I instead made them public. This does not seem like a particularly good idea, but I chose to show some of the private stuff instead of making a huge interface(in terms of method count). I could have considered using a (richer) invariant to better make sure that my privates were shielded from harm.

I made no BON-specification for the Control class and how it works, because it has no public interface except for its constructor.

Considering how our architecture and our system works, the way I have designed the cards both as Enums and as Card objects can seem a bit overkill, especially the very large inheritance hierachy on the Cards. It worked out well in the end, because even though it is clunky and akward, it makes much of the implementation easier - especially with a Factory such as CardFactory.

\subsubsection{BON specification}
We have included all of our BON in section \ref{sec:BON} on page \pageref{sec:BON}. Most of our BON was started before we started coding, but a lot of the classes have since been expanded with more contracts and more queries.