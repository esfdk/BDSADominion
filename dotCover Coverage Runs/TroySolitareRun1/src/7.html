<html>
	<head>
		<script type="text/javascript" src="../js/coverreport.js">

		</script><script type="text/javascript">
			RANGES_7 = [
   [25,9,25,107,'dccv']
, [35,9,35,26,'dccv']
, [37,13,37,98,'dccv']
, [39,13,39,53,'dccv']
, [40,9,40,10,'dccv']
, [54,17,56,31,'dccv']
, [56,73,56,98,'dccv']
, [67,17,67,25,'dccv']
, [68,17,68,27,'dccv']
, [77,13,77,75,'dccv']
, [78,13,78,32,'dccv']
, [80,13,80,56,'dccv']
, [81,9,81,10,'dccv']
, [91,13,91,53,'dccv']
, [105,13,105,104,'dccv']
, [107,13,107,42,'dccv']
, [108,9,108,10,'dccv']
, [136,13,136,97,'dccv']
, [138,47,138,76,'dccv']
, [138,94,138,95,'dccv']
, [138,22,138,43,'dccv']
, [140,17,140,50,'dccv']
, [138,44,138,46,'dccv']
, [142,9,142,10,'dccv']
, [152,13,152,60,'dccv']
, [153,13,153,59,'dccv']
, [155,13,155,68,'dccv']
, [157,13,157,56,'dccv']
, [159,13,159,76,'dccv']
, [165,13,165,49,'dccv']
, [167,13,167,72,'dccv']
, [169,13,169,33,'dccv']
, [170,9,170,10,'dccv']
, [194,13,194,71,'dccv']
, [196,13,196,70,'dccv']
, [199,75,199,91,'dccv']
, [199,26,199,71,'dccv']
, [201,21,201,136,'dccv']
, [199,72,199,74,'dccv']
, [207,17,207,72,'dccv']
, [208,17,208,71,'dccv']
, [210,9,210,10,'dccv']
, [223,13,223,88,'dccv']
, [224,13,224,64,'dccv']
, [226,13,226,25,'dccv']
, [56,31,56,58,'dccv']
, [56,73,56,79,'dccv']
, [56,58,56,73,'dccv']
, [138,76,138,94,'dccv']
, [118,13,118,44,'dcuc']
, [118,71,118,73,'dcuc']
, [119,9,119,10,'dcuc']
, [161,17,161,32,'dcuc']
, [162,17,162,24,'dcuc']
, [180,13,180,49,'dcuc']
, [181,9,181,10,'dcuc']
, [118,44,118,71,'dcuc']
];
		</script><link rel="stylesheet" type="text/css" href="../css/coverreport.css" />
	</head><body>
		<code id="src7" class="dotCoverSource"><pre>namespace BDSADominion.Networking
{
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Net;
    using System.Net.Sockets;

    /// &lt;summary&gt;
    /// This is the server that handles all communication over the network
    /// &lt;/summary&gt;
    /// &lt;author&gt;
    /// Christian &#39;Troy&#39; Jensen (chrj@itu.dk) based heavily on code from Simon Henriksen (shen@itu.dk)
    /// &lt;/author&gt;
    internal class Server
    {
        /// &lt;summary&gt;
        /// The Socket that handles communication
        /// &lt;/summary&gt;
        private readonly Socket socket;

        /// &lt;summary&gt;
        /// The clients that are connected keyed by their id
        /// &lt;/summary&gt;
        private readonly Dictionary&lt;int, Connection&gt; connectedClients = new Dictionary&lt;int, Connection&gt;();

        /// &lt;summary&gt;
        /// the current highest Id
        /// &lt;/summary&gt;
        private int id = 0;

        /// &lt;summary&gt;
        /// Initializes a new instance of the &lt;see cref=&quot;Server&quot;/&gt; class.
        /// &lt;/summary&gt;
        internal Server()
        {
            socket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);

            ClientConnectedEvent += ClientConnected;
        }

        /// &lt;summary&gt;
        /// event tells when a client connects
        /// &lt;/summary&gt;
        internal event ConnectedClientHandler ClientConnectedEvent;

        /// &lt;summary&gt;
        /// Gets Ip of this computer, that clients can connect to
        /// &lt;/summary&gt;
        internal IPAddress Ip
        {
            get
            {
                return
                    Dns.GetHostEntry(Dns.GetHostName()).AddressList.Where(
                        ip =&gt; ip.ToString().Count(chr =&gt; chr.Equals(&#39;.&#39;)) == 3).FirstOrDefault();
            }
        }

        /// &lt;summary&gt;
        /// Gets an incrementing values, which is the next assignment of Id
        /// &lt;/summary&gt;
        private int NextIdAssign
        {
            get
            {
                id += 1;
                return id;
            }
        }

        /// &lt;summary&gt;
        /// This starts the Server. Must be called before the Server is used
        /// &lt;/summary&gt;
        internal void Start()
        {
            socket.Bind(new IPEndPoint(IPAddress.Any, NetworkConst.PORT));
            socket.Listen(100);

            socket.BeginAccept(AcceptCallback, socket);
        }

        /// &lt;summary&gt;
        /// Returns a list of all clients connected to the server
        /// &lt;/summary&gt;
        /// &lt;returns&gt;
        /// The list
        /// &lt;/returns&gt;
        internal List&lt;Connection&gt; GetClientList()
        {
            return connectedClients.Values.ToList();
        }

        /// &lt;summary&gt;
        /// This sends a system message to all clients exept the specified
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;message&quot;&gt;
        /// The message to be sent
        /// &lt;/param&gt;
        /// &lt;param name=&quot;client&quot;&gt;
        /// The client that originally sent the message, who it will not be sent back to
        /// &lt;/param&gt;
        internal void SystemMessage(string message, Connection client)
        {
            string compoundMessage = string.Format(&quot;{0}|{1}|{2}&lt;EOF&gt;&quot;, 0, MessageType.System, message);

            client.Send(compoundMessage);
        }

        /// &lt;summary&gt;
        /// Send a system message to all clients
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;message&quot;&gt;
        /// The message to be sent
        /// &lt;/param&gt;
        internal void SystemMessage(string message)
        {
            GetClientList().ForEach(cli =&gt; SystemMessage(message, cli));
        }

        /// &lt;summary&gt;
        /// Use this to send a message recieved from one client to all clients except the sender.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;message&quot;&gt;
        /// The message, must be clean
        /// &lt;/param&gt;
        /// &lt;param name=&quot;clientId&quot;&gt;
        /// The Id of the sender.
        /// &lt;/param&gt;
        /// &lt;param name=&quot;type&quot;&gt;
        /// The type of message being sent
        /// &lt;/param&gt;
        internal void ForwardMessage(string message, int clientId, MessageType type)
        {
            ////Console.WriteLine(&quot;Server.ForwardMessage: Forwarding message: &quot; + message);
            string compoundMessage = string.Format(&quot;{0}|{1}|{2}&lt;EOF&gt;&quot;, clientId, type, message);

            foreach (Connection connection in GetClientList().Where(con =&gt; con.Id != clientId))
            {
                connection.Send(compoundMessage);
            }
        }

        /// &lt;summary&gt;
        /// Called when a client connects to the server.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;asyncResult&quot;&gt;
        /// The async result.
        /// &lt;/param&gt;
        private void AcceptCallback(IAsyncResult asyncResult)
        {
            Socket server = (Socket)asyncResult.AsyncState;
            Socket client = server.EndAccept(asyncResult);

            Connection conn = new Connection(client, NextIdAssign);

            server.BeginAccept(AcceptCallback, server);

            if (ClientConnectedEvent != null &amp; !ClientConnectedEvent(conn))
            {
                client.Close();
                return;
            }

            connectedClients.Add(conn.Id, conn);

            conn.ClosedConnectionEvent += ClientConnectionDisconnected;

            conn.BeginReceive();
        }

        /// &lt;summary&gt;
        /// Called when a client disconnect
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;connect&quot;&gt;
        /// The Connection
        /// &lt;/param&gt;
        private void ClientConnectionDisconnected(Connection connect)
        {
            connectedClients.Remove(connect.Id);
        }

        /// &lt;summary&gt;
        /// Called when the server receives a message
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;conn&quot;&gt;
        /// The connection
        /// &lt;/param&gt;
        /// &lt;param name=&quot;message&quot;&gt;
        /// The message to be sent
        /// &lt;/param&gt;
        private void ServerRecievedMessage(Connection conn, string message)
        {
            string[] messageParts = message.Split(new char[] { &#39;|&#39; });
            ////Console.WriteLine(&quot;Server.ServerReceivedMessage: Server received &#39;{0}&#39; of type {1} from player {2}&quot;, messageParts[1], messageParts[0], conn.Id);
            if (messageParts[1].StartsWith(&quot;&lt;STGM&gt;&quot;) &amp;&amp; conn.Id == 1)
            {
                ////Console.WriteLine(&quot;Server.ServerReceivedMessage: Start Game!&quot;);
                foreach (KeyValuePair&lt;int, Connection&gt; connectedClient in connectedClients)
                {
                    SystemMessage(string.Format(&quot;&lt;STGM&gt;,{0},{1}&quot;, connectedClients.Count, connectedClient.Key), connectedClient.Value);
                }
            }
            else
            {
                MessageType messageType;
                MessageType.TryParse(messageParts[0], out messageType);
                ForwardMessage(messageParts[1], conn.Id, messageType);
            }
        }

        /// &lt;summary&gt;
        /// Called when a client connects
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;conn&quot;&gt;
        /// The Connection
        /// &lt;/param&gt;
        /// &lt;returns&gt;
        /// If a client connected
        /// &lt;/returns&gt;
        private bool ClientConnected(Connection conn)
        {
            Console.WriteLine(&quot;Server.ClientConnected: Client {0} connected&quot;, conn.Id);
            conn.ReceivedMessageEvent += ServerRecievedMessage;

            return true;
        }
    }
}
</pre></code><script type="text/javascript">
			applyranges('src7', RANGES_7)
		</script>
	</body>
</html>