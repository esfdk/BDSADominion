<html>
	<head>
		<script type="text/javascript" src="../js/coverreport.js">

		</script><script type="text/javascript">
			RANGES_6 = [
   [22,9,22,63,'dccv']
, [27,9,27,66,'dccv']
, [32,9,32,63,'dccv']
, [37,9,37,61,'dccv']
, [42,9,42,66,'dccv']
, [54,9,54,41,'dccv']
, [56,13,56,46,'dccv']
, [57,13,57,53,'dccv']
, [58,9,58,10,'dccv']
, [75,19,75,43,'dccv']
, [83,19,83,46,'dccv']
, [94,17,94,39,'dccv']
, [115,19,115,31,'dccv']
, [123,19,123,33,'dccv']
, [131,19,131,36,'dccv']
, [148,13,148,53,'dccv']
, [149,13,149,31,'dccv']
, [150,9,150,10,'dccv']
, [173,13,173,26,'dccv']
, [176,21,176,39,'dccv']
, [181,21,181,47,'dccv']
, [182,21,182,27,'dccv']
, [222,13,222,26,'dccv']
, [229,21,229,44,'dccv']
, [230,21,230,40,'dccv']
, [231,21,231,27,'dccv']
, [233,21,233,44,'dccv']
, [234,21,234,36,'dccv']
, [235,21,235,27,'dccv']
, [237,21,237,44,'dccv']
, [238,21,238,38,'dccv']
, [239,21,239,27,'dccv']
, [270,13,270,38,'dccv']
, [272,13,272,26,'dccv']
, [278,21,278,40,'dccv']
, [279,21,279,27,'dccv']
, [348,18,348,28,'dccv']
, [350,17,350,48,'dccv']
, [355,17,355,28,'dccv']
, [348,42,348,45,'dccv']
, [348,29,348,40,'dccv']
, [357,9,357,10,'dccv']
, [367,13,367,31,'dccv']
, [369,17,369,34,'dccv']
, [372,13,372,34,'dccv']
, [373,9,373,10,'dccv']
, [380,35,380,39,'dccv']
, [380,22,380,31,'dccv']
, [382,17,382,36,'dccv']
, [380,32,380,34,'dccv']
, [385,13,385,26,'dccv']
, [387,35,387,41,'dccv']
, [387,22,387,31,'dccv']
, [389,17,389,36,'dccv']
, [387,32,387,34,'dccv']
, [392,13,392,28,'dccv']
, [394,13,394,26,'dccv']
, [395,9,395,10,'dccv']
, [462,13,462,47,'dccv']
, [463,13,463,47,'dccv']
, [464,13,464,47,'dccv']
, [465,13,465,47,'dccv']
, [469,17,469,39,'dccv']
, [470,17,470,39,'dccv']
, [471,17,471,39,'dccv']
, [472,17,472,39,'dccv']
, [467,13,467,37,'dccv']
, [475,13,475,34,'dccv']
, [477,17,477,38,'dccv']
, [479,21,479,42,'dccv']
, [481,25,481,47,'dccv']
, [484,21,484,43,'dccv']
, [487,17,487,39,'dccv']
, [490,13,490,50,'dccv']
, [494,17,494,36,'dccv']
, [492,13,492,33,'dccv']
, [499,17,499,36,'dccv']
, [497,13,497,33,'dccv']
, [504,17,504,36,'dccv']
, [502,13,502,33,'dccv']
, [509,17,509,36,'dccv']
, [507,13,507,33,'dccv']
, [514,17,514,39,'dccv']
, [512,13,512,36,'dccv']
, [537,9,537,10,'dccv']
, [106,17,106,36,'dcuc']
, [178,25,178,42,'dcuc']
, [184,21,184,42,'dcuc']
, [186,25,186,31,'dcuc']
, [189,21,189,50,'dcuc']
, [190,21,190,27,'dcuc']
, [225,21,225,44,'dcuc']
, [226,21,226,37,'dcuc']
, [227,21,227,27,'dcuc']
, [275,21,275,37,'dcuc']
, [276,21,276,27,'dcuc']
, [281,21,281,36,'dcuc']
, [282,21,282,27,'dcuc']
, [284,21,284,38,'dcuc']
, [285,21,285,27,'dcuc']
, [319,13,319,26,'dcuc']
, [322,21,322,50,'dcuc']
, [323,21,323,32,'dcuc']
, [324,21,324,27,'dcuc']
, [326,21,326,53,'dcuc']
, [327,21,327,35,'dcuc']
, [328,21,328,27,'dcuc']
, [330,21,330,43,'dcuc']
, [331,21,331,39,'dcuc']
, [332,21,332,27,'dcuc']
, [334,21,334,43,'dcuc']
, [335,21,335,41,'dcuc']
, [336,21,336,27,'dcuc']
, [352,21,352,27,'dcuc']
, [405,9,405,10,'dcuc']
, [415,35,415,48,'dcuc']
, [415,22,415,31,'dcuc']
, [417,17,417,144,'dcuc']
, [419,21,419,34,'dcuc']
, [415,32,415,34,'dcuc']
, [423,13,423,34,'dcuc']
, [423,61,423,63,'dcuc']
, [425,17,425,30,'dcuc']
, [428,13,428,37,'dcuc']
, [428,64,428,66,'dcuc']
, [430,17,430,30,'dcuc']
, [433,13,433,36,'dcuc']
, [433,63,433,65,'dcuc']
, [435,17,435,30,'dcuc']
, [438,13,438,34,'dcuc']
, [438,61,438,63,'dcuc']
, [440,17,440,30,'dcuc']
, [443,13,443,39,'dcuc']
, [443,66,443,68,'dcuc']
, [445,17,445,30,'dcuc']
, [448,13,448,25,'dcuc']
, [449,9,449,10,'dcuc']
, [423,34,423,61,'dcuc']
, [428,37,428,64,'dcuc']
, [433,36,433,63,'dcuc']
, [438,34,438,61,'dcuc']
, [443,39,443,66,'dcuc']
];
		</script><link rel="stylesheet" type="text/css" href="../css/coverreport.css" />
	</head><body>
		<code id="src6" class="dotCoverSource"><pre>namespace BDSADominion.Gamestate
{
    using System.Collections.Generic;
    using System.Diagnostics.Contracts;
    using System.Linq;

    using BDSADominion.Gamestate.Card_Types;

    /// &lt;summary&gt;
    /// Each player is represented by this object that keeps track of their decks, hands, discard piles, etc.
    /// &lt;/summary&gt;
    /// &lt;author&gt;
    /// Jakob Melnyk (jmel@itu.dk)
    /// &lt;/author&gt;
    public class Player
    {
        #region Fields

        /// &lt;summary&gt;
        /// The deck belonging to the player.
        /// &lt;/summary&gt;
        private readonly Stack&lt;Card&gt; deck = new Stack&lt;Card&gt;();

        /// &lt;summary&gt;
        /// The discard pile of the player.
        /// &lt;/summary&gt;
        private readonly Stack&lt;Card&gt; discard = new Stack&lt;Card&gt;();

        /// &lt;summary&gt;
        /// The cards the player has played this turn.
        /// &lt;/summary&gt;
        private readonly List&lt;Card&gt; played = new List&lt;Card&gt;();

        /// &lt;summary&gt;
        /// The cards in the hand of the player.
        /// &lt;/summary&gt;
        private readonly List&lt;Card&gt; hand = new List&lt;Card&gt;();

        /// &lt;summary&gt;
        /// The cards in the temporary zone.
        /// &lt;/summary&gt;
        private readonly List&lt;Card&gt; temporary = new List&lt;Card&gt;();

        #endregion

        #region Properties

        /// &lt;summary&gt;
        /// Initializes a new instance of the &lt;see cref=&quot;Player&quot;/&gt; class.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;playerNumber&quot;&gt;
        /// The player number.
        /// &lt;/param&gt;
        public Player(uint playerNumber)
        {
            this.PlayerNumber = playerNumber;
            AllCards = new Dictionary&lt;Card, bool&gt;();
        }

        /// &lt;summary&gt;
        /// Gets the Player&#39;s number.
        /// &lt;/summary&gt;
        public uint PlayerNumber { get; private set; }

        /// &lt;summary&gt;
        /// Gets all the cards belonging to the player.
        /// &lt;/summary&gt;
        public Dictionary&lt;Card, bool&gt; AllCards { get; private set; }

        /// &lt;summary&gt;
        /// Gets the size of the deck.
        /// &lt;/summary&gt;
        public uint DeckSize
        {
            get { return (uint)deck.Count; }
        }

        /// &lt;summary&gt;
        /// Gets the size of the discard pile.
        /// &lt;/summary&gt;
        public uint DiscardSize
        {
            get { return (uint)discard.Count; }
        }

        /// &lt;summary&gt;
        /// Gets the card at the top of the discard pile.
        /// &lt;/summary&gt;
        public Card TopOfDiscard
        {
            get
            {
                Contract.Requires(DiscardSize != 0);
                return discard.Peek();
            }
        }

        /// &lt;summary&gt;
        /// Gets the card at the top of the deck.
        /// &lt;/summary&gt;
        public Card TopOfDeck
        {
            get
            {
                Contract.Requires(DeckSize != 0);
                return deck.Peek();
            }
        }

        /// &lt;summary&gt;
        /// Gets the Player&#39;s hand.
        /// &lt;/summary&gt;
        public List&lt;Card&gt; Hand
        {
            get { return hand; }
        }

        /// &lt;summary&gt;
        /// Gets the cards played by the Player.
        /// &lt;/summary&gt;
        public List&lt;Card&gt; Played
        {
            get { return played; }
        }

        /// &lt;summary&gt;
        /// Gets the card in the temporary zone.
        /// &lt;/summary&gt;
        public List&lt;Card&gt; TempZone
        {
            get { return temporary; }
        }
        #endregion

        /// &lt;summary&gt;
        /// Moves a card from the hand to the temporary zone.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;card&quot;&gt;
        /// The card to be moved.
        /// &lt;/param&gt;
        public void MoveFromHandToTemporary(Card card)
        {
            Contract.Requires(Hand.Contains(card));

            Contract.Ensures(!hand.Contains(card));
            Contract.Ensures(TempZone.Contains(card));

            temporary.Add(hand[hand.IndexOf(card)]);
            hand.Remove(card);
        }

        /// &lt;summary&gt;
        /// Moves a card from either the deck or the discard pile into the temporary zone.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;zone&quot;&gt;
        /// The zone to move card from.
        /// &lt;/param&gt;
        public void MoveFromZoneToTemporary(Zone zone)
        {
            Contract.Requires(zone == Zone.Deck | zone == Zone.Discard);

            Contract.Requires(zone == Zone.Deck ? !(DeckSize == 0 &amp; DiscardSize == 0) : true);
            Contract.Requires(zone == Zone.Discard ? DiscardSize != 0 : true);

            Contract.Ensures(TempZone.Count == Contract.OldValue(TempZone.Count) + 1);

            Contract.Ensures(zone == Zone.Deck ? DeckSize == Contract.OldValue(DeckSize) - 1 : true);
            Contract.Ensures(DeckSize != 0 ? TopOfDeck != Contract.OldValue(TopOfDeck) : true);

            Contract.Ensures(zone == Zone.Discard ? DiscardSize == Contract.OldValue(DiscardSize) - 1 : true);
            Contract.Ensures(DiscardSize != 0 ? TopOfDiscard != Contract.OldValue(TopOfDiscard) : true);

            switch (zone)
            {
                case Zone.Deck:
                    if (DeckSize == 0)
                    {
                        ShuffleDiscard();
                    }

                    temporary.Add(deck.Pop());
                    break;
                case Zone.Discard:
                    if (DiscardSize == 0)
                    {
                        break;
                    }

                    temporary.Add(discard.Pop());
                    break;
            }
        }

        /// &lt;summary&gt;
        /// Move a card from the temporary zone to another zone.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;card&quot;&gt;
        /// The card to move from the temporary zone.
        /// &lt;/param&gt;
        /// &lt;param name=&quot;zone&quot;&gt;
        /// The zone to move the card to.
        /// &lt;/param&gt;
        public void MoveFromTemporaryToZone(Card card, Zone zone)
        {
            Contract.Requires(zone == Zone.Deck | zone == Zone.Discard | zone == Zone.Hand | zone == Zone.Played);
            Contract.Requires(TempZone.Contains(card));

            Contract.Ensures(TempZone.Count == Contract.OldValue(TempZone.Count) - 1);

            Contract.Ensures(zone == Zone.Deck ? DeckSize == Contract.OldValue(DeckSize) + 1 : true);
            Contract.Ensures(zone == Zone.Deck ? TopOfDeck == Contract.OldValue(TempZone[TempZone.Count - 1]) : true);

            Contract.Ensures(zone == Zone.Discard ? DiscardSize == Contract.OldValue(DiscardSize) + 1 : true);
            Contract.Ensures(zone == Zone.Discard ? TopOfDiscard == Contract.OldValue(TempZone[TempZone.Count - 1]) : true);

            Contract.Ensures(zone == Zone.Hand ? (Hand.Count == Contract.OldValue(Hand.Count) + 1) &amp; Hand.Contains(card) : true);
            Contract.Ensures(zone == Zone.Hand ? Hand[Hand.Count - 1] == Contract.OldValue(TempZone[TempZone.Count - 1]) : true);

            Contract.Ensures(zone == Zone.Played ? (Played.Count == Contract.OldValue(Played.Count) + 1) &amp; Played.Contains(card) : true);
            Contract.Ensures(zone == Zone.Played ? Played[Played.Count - 1] == Contract.OldValue(TempZone[TempZone.Count - 1]) : true);

            switch (zone)
            {
                case Zone.Deck:
                    temporary.Remove(card);
                    deck.Push(card);
                    break;
                case Zone.Discard:
                    temporary.Remove(card);
                    discard.Push(card);
                    break;
                case Zone.Hand:
                    temporary.Remove(card);
                    hand.Add(card);
                    break;
                case Zone.Played:
                    temporary.Remove(card);
                    played.Add(card);
                    break;
            }
        }

        /// &lt;summary&gt;
        /// Adds a card to a player&#39;s hand.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;card&quot;&gt;
        /// The card to be added to the zone.
        /// &lt;/param&gt;
        /// &lt;param name=&quot;zone&quot;&gt;
        /// The zone to add the card to.
        /// &lt;/param&gt;
        public void AddCardToZone(Card card, Zone zone)
        {
            Contract.Requires(zone == Zone.Deck | zone == Zone.Discard | zone == Zone.Hand | zone == Zone.Played);

            Contract.Ensures(AllCards[card]);

            Contract.Ensures(zone == Zone.Hand ? Hand[Hand.Count - 1] == card : true);
            Contract.Ensures(zone == Zone.Hand ? hand.Count == Contract.OldValue(hand.Count) + 1 : true);

            Contract.Ensures(zone == Zone.Played ? Played[Played.Count - 1] == card : true);
            Contract.Ensures(zone == Zone.Played ? played.Count == Contract.OldValue(played.Count) + 1 : true);

            Contract.Ensures(zone == Zone.Deck ? TopOfDeck == card : true);
            Contract.Ensures(zone == Zone.Deck ? DeckSize == Contract.OldValue(DeckSize) + 1 : true);

            Contract.Ensures(zone == Zone.Discard ? TopOfDiscard == card : true);
            Contract.Ensures(zone == Zone.Discard ? DiscardSize == Contract.OldValue(DiscardSize) + 1 : true);

            AllCards.Add(card, true);

            switch (zone)
            {
                case Zone.Deck:
                    deck.Push(card);
                    break;
                case Zone.Discard:
                    discard.Push(card);
                    break;
                case Zone.Hand:
                    hand.Add(card);
                    break;
                case Zone.Played:
                    played.Add(card);
                    break;
            }
        }

        /// &lt;summary&gt;
        /// Removes a card from the player.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;card&quot;&gt;
        /// The card to be removed.
        /// &lt;/param&gt;
        /// &lt;param name=&quot;zone&quot;&gt;
        /// The zone the card is currently in.
        /// &lt;/param&gt;
        public void RemoveCardFromZone(Card card, Zone zone)
        {
            Contract.Requires(zone == Zone.Deck | zone == Zone.Discard | zone == Zone.Hand | zone == Zone.Played);
            Contract.Requires(AllCards.ContainsKey(card));

            Contract.Requires(zone == Zone.Hand ? Hand.Contains(card) : true);
            Contract.Requires(zone == Zone.Played ? Played.Contains(card) : true);
            Contract.Requires(zone == Zone.Deck ? !(DeckSize == 0 &amp; DiscardSize == 0) : true);
            Contract.Requires(zone == Zone.Discard ? DiscardSize != 0 : true);

            Contract.Ensures(!AllCards.ContainsKey(card));

            Contract.Ensures(zone == Zone.Hand ? !Hand.Contains(card) : true);
            Contract.Ensures(zone == Zone.Hand ? Hand.Count == Contract.OldValue(hand.Count) - 1 : true);

            Contract.Ensures(zone == Zone.Played ? !Played.Contains(card) : true);
            Contract.Ensures(zone == Zone.Played ? Played.Count == Contract.OldValue(played.Count) - 1 : true);

            Contract.Ensures(zone == Zone.Deck ? DeckSize == Contract.OldValue(DeckSize) - 1 : true);
            Contract.Ensures(zone == Zone.Discard ? DiscardSize == Contract.OldValue(DiscardSize) - 1 : true);

            switch (zone)
            {
                case Zone.Deck:
                    AllCards.Remove(deck.Peek());
                    deck.Pop();
                    break;
                case Zone.Discard:
                    AllCards.Remove(discard.Peek());
                    discard.Pop();
                    break;
                case Zone.Hand:
                    AllCards.Remove(card);
                    hand.Remove(card);
                    break;
                case Zone.Played:
                    AllCards.Remove(card);
                    played.Remove(card);
                    break;
            }
        }

        /// &lt;summary&gt;
        /// Makes the player draw a specific amount of cards.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;amount&quot;&gt;
        /// The amount of cards to be drawn.
        /// &lt;/param&gt;
        public void DrawCards(uint amount)
        {
            for (int i = 1; i &lt;= amount; i++)
            {
                if (DeckSize + DiscardSize &lt; 1)
                {
                    break;
                }

                DrawCard();
            }
        }

        /// &lt;summary&gt;
        /// Makes the player draw a card from his deck. The player will shuffle the discard pile into the deck if necessary.
        /// &lt;/summary&gt;
        public void DrawCard()
        {
            Contract.Requires(DeckSize + DiscardSize != 0);

            Contract.Ensures(Hand.Count == Contract.OldValue(Hand.Count) + 1);
            if (DeckSize == 0)
            {
                ShuffleDiscard();
            }

            hand.Add(deck.Pop());
        }

        /// &lt;summary&gt;
        /// Takes all the cards in the players hand and in the played zone, and puts them in the discard pile. Then draws five cards.
        /// &lt;/summary&gt;
        public void CleanUp()
        {
            foreach (Card card in hand)
            {
                discard.Push(card);
            }

            hand.Clear();

            foreach (Card card in played)
            {
                discard.Push(card);
            }

            played.Clear();

            DrawCards(5);
        }

        /// &lt;summary&gt;
        /// A card cannot be in the DECK, DISCARD, HAND or PLAYED zones of a player 
        /// if it is not in the &#39;ALL CARDS&#39;.
        /// &lt;/summary&gt;
        [ContractInvariantMethod]
        private void ObjectInvariant()
        {
            Contract.Invariant(InvariantHelper());
        }

        /// &lt;summary&gt;
        /// Helper method for the object invariant.
        /// &lt;/summary&gt;
        /// &lt;returns&gt;
        /// True, if invariant holds. False, if not.
        /// &lt;/returns&gt;
        private bool InvariantHelper()
        {
            foreach (Card card in AllCards.Keys)
            {
                if (!deck.Contains(card) &amp; !discard.Contains(card) &amp; !played.Contains(card) &amp; !hand.Contains(card) &amp; !temporary.Contains(card))
                {
                    return false;
                }
            }

            if (deck.Any(card =&gt; !AllCards.ContainsKey(card)))
            {
                return false;
            }

            if (discard.Any(card =&gt; !AllCards.ContainsKey(card)))
            {
                return false;
            }

            if (played.Any(card =&gt; !AllCards.ContainsKey(card)))
            {
                return false;
            }

            if (hand.Any(card =&gt; !AllCards.ContainsKey(card)))
            {
                return false;
            }

            if (temporary.Any(card =&gt; !AllCards.ContainsKey(card)))
            {
                return false;
            }

            return true;
        }

        /// &lt;summary&gt;
        /// Shuffles the discard pile into the deck.
        /// &lt;/summary&gt;
        private void ShuffleDiscard()
        {
            Contract.Requires(DeckSize == 0);
            Contract.Requires(DiscardSize != 0);

            Contract.Ensures(DeckSize != 0);
            Contract.Ensures(DiscardSize == 0);

            Stack&lt;Card&gt; a = new Stack&lt;Card&gt;();
            Stack&lt;Card&gt; b = new Stack&lt;Card&gt;();
            Stack&lt;Card&gt; c = new Stack&lt;Card&gt;();
            Stack&lt;Card&gt; d = new Stack&lt;Card&gt;();

            while (DiscardSize &gt;= 4)
            {
                a.Push(discard.Pop());
                b.Push(discard.Pop());
                c.Push(discard.Pop());
                d.Push(discard.Pop());
            }

            if (DiscardSize &gt;= 1)
            {
                if (DiscardSize &gt;= 2)
                {
                    if (DiscardSize &gt;= 3)
                    {
                        c.Push(discard.Pop());
                    }

                    b.Push(discard.Pop());
                }

                a.Push(discard.Pop());
            }

            Stack&lt;Card&gt; temp = new Stack&lt;Card&gt;();

            while (a.Count != 0)
            {
                temp.Push(a.Pop());
            }

            while (b.Count != 0)
            {
                temp.Push(b.Pop());
            }

            while (c.Count != 0)
            {
                temp.Push(c.Pop());
            }

            while (d.Count != 0)
            {
                temp.Push(d.Pop());
            }

            while (temp.Count != 0)
            {
                deck.Push(temp.Pop());
            }


            // Following code makes the pseudo-shuffling random, but would force us to send the deck each time it is shuffled, due to its pseudo-random nature.
            /*
            Random r = new Random();
            List&lt;Card&gt; cards = discard.ToList();

            for (int i = 0; i &lt; cards.Count; i++)
            {
                int index = r.Next(cards.Count);
                Card c = cards[i];
                cards[i] = cards[index];
                cards[index] = c;
            }

            discard.Clear();

            foreach (Card card in cards)
            {
                deck.Push(card);
            }*/
        }
    }
}</pre></code><script type="text/javascript">
			applyranges('src6', RANGES_6)
		</script>
	</body>
</html>