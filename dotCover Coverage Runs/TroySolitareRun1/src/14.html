<html>
	<head>
		<script type="text/javascript" src="../js/coverreport.js">

		</script><script type="text/javascript">
			RANGES_14 = [
   [26,9,59,15,'dccv']
, [106,9,106,25,'dccv']
, [108,13,108,40,'dccv']
, [110,13,110,62,'dccv']
, [114,17,114,51,'dccv']
, [116,17,116,47,'dccv']
, [112,13,112,35,'dccv']
, [130,13,130,22,'dccv']
, [132,17,132,51,'dccv']
, [133,17,133,53,'dccv']
, [134,17,134,58,'dccv']
, [168,13,168,31,'dccv']
, [169,13,169,33,'dccv']
, [173,17,173,70,'dccv']
, [175,17,175,44,'dccv']
, [177,17,177,44,'dccv']
, [181,22,181,49,'dccv']
, [183,21,183,33,'dccv']
, [171,13,171,34,'dccv']
, [192,13,192,25,'dccv']
, [209,13,209,60,'dccv']
, [211,17,211,70,'dccv']
, [212,17,212,38,'dccv']
, [213,17,213,66,'dccv']
, [214,17,214,69,'dccv']
, [215,17,215,62,'dccv']
, [216,17,219,38,'dccv']
, [220,17,220,66,'dccv']
, [221,17,221,50,'dccv']
, [236,13,262,19,'dccv']
, [264,13,264,54,'dccv']
, [266,13,266,69,'dccv']
, [268,13,268,45,'dccv']
, [270,39,270,49,'dccv']
, [270,22,270,35,'dccv']
, [272,22,272,32,'dccv']
, [274,21,274,65,'dccv']
, [272,41,272,44,'dccv']
, [272,33,272,39,'dccv']
, [277,22,277,32,'dccv']
, [279,21,279,65,'dccv']
, [277,41,277,44,'dccv']
, [277,33,277,39,'dccv']
, [282,17,282,37,'dccv']
, [270,36,270,38,'dccv']
, [285,13,285,59,'dccv']
, [287,13,287,38,'dccv']
, [288,13,288,45,'dccv']
, [289,13,289,42,'dccv']
, [290,13,290,50,'dccv']
, [291,13,291,42,'dccv']
, [293,13,293,25,'dccv']
, [294,13,294,27,'dccv']
, [305,13,305,62,'dccv']
, [306,13,306,101,'dccv']
, [307,13,307,82,'dccv']
, [308,13,308,81,'dccv']
, [309,13,309,55,'dccv']
, [310,13,310,52,'dccv']
, [311,13,311,47,'dccv']
, [312,13,312,49,'dccv']
, [313,13,313,58,'dccv']
, [315,13,315,33,'dccv']
, [318,21,318,37,'dccv']
, [319,21,319,27,'dccv']
, [321,21,321,37,'dccv']
, [325,13,325,78,'dccv']
, [326,9,326,10,'dccv']
, [336,13,336,47,'dccv']
, [337,13,337,59,'dccv']
, [338,13,338,86,'dccv']
, [339,13,339,28,'dccv']
, [352,13,352,66,'dccv']
, [354,17,354,77,'dccv']
, [354,101,354,104,'dccv']
, [358,17,358,77,'dccv']
, [358,132,358,135,'dccv']
, [361,13,361,35,'dccv']
, [363,13,363,25,'dccv']
, [364,9,364,10,'dccv']
, [376,13,376,29,'dccv']
, [378,17,378,29,'dccv']
, [382,17,382,27,'dccv']
, [383,17,383,29,'dccv']
, [385,9,385,10,'dccv']
, [395,13,395,39,'dccv']
, [396,13,396,25,'dccv']
, [397,9,397,10,'dccv']
, [414,13,414,40,'dccv']
, [415,13,415,43,'dccv']
, [416,13,416,31,'dccv']
, [419,21,419,36,'dccv']
, [420,21,420,45,'dccv']
, [421,21,421,27,'dccv']
, [424,21,424,42,'dccv']
, [425,21,425,43,'dccv']
, [426,21,426,27,'dccv']
, [429,21,429,36,'dccv']
, [430,21,430,27,'dccv']
, [433,47,433,57,'dccv']
, [433,30,433,43,'dccv']
, [435,25,435,45,'dccv']
, [433,44,433,46,'dccv']
, [438,21,438,36,'dccv']
, [439,21,439,42,'dccv']
, [440,21,440,27,'dccv']
, [443,21,443,45,'dccv']
, [444,21,444,42,'dccv']
, [445,21,445,43,'dccv']
, [446,21,446,27,'dccv']
, [449,21,449,36,'dccv']
, [450,21,450,45,'dccv']
, [451,21,451,27,'dccv']
, [461,21,461,47,'dccv']
, [462,21,462,65,'dccv']
, [466,25,466,62,'dccv']
, [467,25,467,67,'dccv']
, [468,25,468,43,'dccv']
, [470,29,470,69,'dccv']
, [471,29,471,49,'dccv']
, [464,21,464,92,'dccv']
, [477,25,477,67,'dccv']
, [478,25,478,68,'dccv']
, [475,21,475,68,'dccv']
, [481,21,481,27,'dccv']
, [491,13,491,58,'dccv']
, [492,13,492,86,'dccv']
, [493,13,493,57,'dccv']
, [495,13,495,25,'dccv']
, [496,9,496,10,'dccv']
, [512,13,512,77,'dccv']
, [514,13,514,51,'dccv']
, [515,13,515,70,'dccv']
, [517,13,517,25,'dccv']
, [518,9,518,10,'dccv']
, [538,13,538,55,'dccv']
, [540,17,540,123,'dccv']
, [541,17,541,44,'dccv']
, [544,13,544,55,'dccv']
, [546,17,546,123,'dccv']
, [548,17,548,58,'dccv']
, [553,17,553,48,'dccv']
, [556,13,556,55,'dccv']
, [558,17,558,37,'dccv']
, [563,25,563,45,'dccv']
, [564,25,564,44,'dccv']
, [565,25,565,31,'dccv']
, [567,25,567,42,'dccv']
, [568,25,568,35,'dccv']
, [573,13,573,25,'dccv']
, [574,9,574,10,'dccv']
, [587,13,587,129,'dccv']
, [589,17,589,109,'dccv']
, [591,21,591,67,'dccv']
, [592,21,592,59,'dccv']
, [595,9,595,10,'dccv']
, [608,13,608,68,'dccv']
, [610,17,610,44,'dccv']
, [612,21,612,65,'dccv']
, [614,21,614,40,'dccv']
, [616,25,616,72,'dccv']
, [617,25,617,47,'dccv']
, [621,9,621,10,'dccv']
, [631,13,631,68,'dccv']
, [633,17,633,37,'dccv']
, [638,25,638,45,'dccv']
, [639,25,639,44,'dccv']
, [640,25,640,52,'dccv']
, [641,25,641,31,'dccv']
, [643,25,643,42,'dccv']
, [644,25,644,52,'dccv']
, [645,25,645,35,'dccv']
, [650,13,650,25,'dccv']
, [651,9,651,10,'dccv']
, [354,77,354,101,'dccv']
, [358,77,358,132,'dccv']
, [118,9,118,10,'dcuc']
, [138,17,138,44,'dcuc']
, [140,17,140,43,'dcuc']
, [144,21,144,70,'dcuc']
, [145,21,145,52,'dcuc']
, [147,21,147,74,'dcuc']
, [148,21,148,39,'dcuc']
, [150,25,150,71,'dcuc']
, [142,17,142,38,'dcuc']
, [154,17,154,62,'dcuc']
, [155,17,155,53,'dcuc']
, [157,9,157,10,'dcuc']
, [179,21,179,34,'dcuc']
, [187,21,187,61,'dcuc']
, [188,21,188,34,'dcuc']
, [223,9,223,10,'dcuc']
, [295,9,295,10,'dcuc']
, [340,9,340,10,'dcuc']
, [454,21,454,36,'dcuc']
, [455,21,455,45,'dcuc']
, [456,21,456,42,'dcuc']
, [457,21,457,43,'dcuc']
, [458,21,458,27,'dcuc']
, [484,21,484,36,'dcuc']
, [485,21,485,27,'dcuc']
, [488,21,488,61,'dcuc']
, [550,21,550,86,'dcuc']
];
		</script><link rel="stylesheet" type="text/css" href="../css/coverreport.css" />
	</head><body>
		<code id="src14" class="dotCoverSource"><pre>namespace BDSADominion
{
    using System;
    using System.Collections.Generic;
    using System.Diagnostics.Contracts;
    using System.Linq;
    using System.Net;
    using BDSADominion.Gamestate;
    using BDSADominion.Gamestate.Card_Types;
    using BDSADominion.GUI;
    using BDSADominion.Networking;
    using Action = BDSADominion.Gamestate.Card_Types.Action;

    /// &lt;summary&gt;
    /// The main class of the game. Contains the network, GUI, gamestate and logic.
    /// &lt;/summary&gt;
    public class Control
    {
        #region Fields

        #region CardCost

        /// &lt;summary&gt;
        /// Used to determine costs of cards.
        /// &lt;/summary&gt;
        private readonly Dictionary&lt;CardName, uint&gt; cardCost = new Dictionary&lt;CardName, uint&gt;
            {
                // The treasure cards.
                { CardName.Copper, 0 },
                { CardName.Silver, 3 },
                { CardName.Gold, 6 },
                
                // The victory cards.
                { CardName.Curse, 0 },
                { CardName.Estate, 2 },
                { CardName.Duchy, 5 },
                { CardName.Province, 8 },

                // The kingdom cards.
                // Cost : 2
                { CardName.Moat, 2 },

                // Cost : 3
                { CardName.Village, 3 },
                { CardName.Woodcutter, 3 },
                
                // Cost : 4
                { CardName.Gardens, 4 },
                { CardName.Smithy, 4 },
                
                // Cost : 5
                { CardName.CouncilRoom, 5 },
                { CardName.Laboratory, 5 },
                { CardName.Festival, 5 },
                { CardName.Market, 5 },
                
                // Cost : 6
                { CardName.Adventurer, 6 }
            };

        #endregion

        /// &lt;summary&gt;
        /// The gui used by this client.
        /// &lt;/summary&gt;
        private GUIInterface gui;

        /// &lt;summary&gt;
        /// Object used to create the gamestate.
        /// &lt;/summary&gt;
        /// &lt;author&gt;
        /// Jakob Melnyk (jmel@itu.dk)
        /// &lt;/author&gt;
        private Dictionary&lt;CardName, uint&gt; startSupply;

        private bool serverStarted = false;

        private int numberOfPlayers;

        /// &lt;summary&gt;
        /// The interface for communicating with the network
        /// &lt;/summary&gt;
        private NetworkingInterface network;

        /// &lt;summary&gt;
        /// The gamestate used for this game.
        /// &lt;/summary&gt;
        /// &lt;author&gt;
        /// Jakob Melnyk (jmel@itu.dk)
        /// &lt;/author&gt;
        private Gamestate.Gamestate gs;

        /// &lt;summary&gt;
        /// The player number of this client.
        /// &lt;/summary&gt;
        private uint clientPlayerNumber;

        #endregion

        /// &lt;summary&gt;
        /// Initializes a new instance of the &lt;see cref=&quot;Control&quot;/&gt; class.
        /// &lt;/summary&gt;
        /// &lt;author&gt;
        /// Christian &#39;Troy&#39; Jensen (chrj@itu.dk)
        /// &lt;/author&gt;
        public Control()
        {
            StartNetwork(clientType());

            network.MessageReceived += ReceivePreGameMessage;

            while (!serverStarted)
            {
                string input = Console.ReadLine();

                network.PreGameMessage(input);
            }
        }

        /// &lt;summary&gt;
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;host&quot;&gt;
        /// The host.
        /// &lt;/param&gt;
        /// &lt;author&gt;
        /// Christian &#39;Troy&#39; Jensen (chrj@itu.dk)
        /// &lt;/author&gt;
        private void StartNetwork(bool host)
        {
            if (host)
            {
                Console.WriteLine(&quot;Host Started&quot;);
                network = new NetworkingInterface();
                Console.WriteLine(network.GetServerIp());
            }
            else
            {
                IPAddress ipAddress = null;

                bool parseSuccess = false;

                while (!parseSuccess)
                {
                    Console.WriteLine(&quot;Please input IP for server:&quot;);
                    string ip = Console.ReadLine();

                    parseSuccess = IPAddress.TryParse(ip, out ipAddress);
                    if (!parseSuccess)
                    {
                        Console.WriteLine(&quot;IP not valid, try again:&quot;);
                    }
                }

                network = new NetworkingInterface(ipAddress);
                Console.WriteLine(&quot;Client started&quot;);
            }
        }

        /// &lt;summary&gt;
        /// &lt;/summary&gt;
        /// &lt;returns&gt;
        /// &lt;/returns&gt;
        /// &lt;author&gt;
        /// Christian &#39;Troy&#39; Jensen (chrj@itu.dk)
        /// &lt;/author&gt;
        private bool clientType()
        {
            bool host = false;
            string input = null;

            while (input == null)
            {
                Console.WriteLine(&quot;Please select server or client:&quot;);

                input = Console.ReadLine();

                if (input.Equals(&quot;client&quot;))
                {
                    host = false;
                }
                else if (input.Equals(&quot;server&quot;))
                {
                    host = true;
                }
                else
                {
                    Console.WriteLine(&quot;Unrecognized input&quot;);
                    input = null;
                }
            }

            return host;
        }

        /// &lt;summary&gt;
        /// used to recieve messages before the game starts
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;message&quot;&gt;
        /// The message that is being passed. Clean
        /// &lt;/param&gt;
        /// &lt;param name=&quot;playerId&quot;&gt;
        /// The Id of the player that sent it.
        /// &lt;/param&gt;
        /// &lt;author&gt;
        /// Christian Jensen (chrj@itu.dk)
        /// &lt;/author&gt;
        private void ReceivePreGameMessage(string message, int playerId)
        {
            if (playerId == 0 &amp; message.Contains(&quot;&lt;STGM&gt;&quot;))
            {
                string[] messageParts = message.Split(new[] { &#39;,&#39; });
                serverStarted = true;
                clientPlayerNumber = uint.Parse(messageParts[2]);
                network.SetResponseList(int.Parse(messageParts[1]));
                numberOfPlayers = int.Parse(messageParts[1]);
                Console.WriteLine(
                    &quot;SYSTEM: GAME STARTED. There are {1} players and you are player {0}&quot;,
                    clientPlayerNumber,
                    numberOfPlayers);
                network.MessageReceived -= ReceivePreGameMessage;
                SetUpGame((uint)numberOfPlayers);
            }
        }

        /// &lt;summary&gt;
        /// Sets up a new game with the number of players pass as parameter.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;numOfPlayers&quot;&gt;
        /// The number Of Players.
        /// &lt;/param&gt;
        /// &lt;author&gt;
        /// Jakob Melnyk (jmel@itu.dk)
        /// &lt;/author&gt;
        private void SetUpGame(uint numOfPlayers)
        {
            startSupply = new Dictionary&lt;CardName, uint&gt;
                {
                    // The treasure cards.
                    { CardName.Copper, 51 },
                    { CardName.Silver, 30 },
                    { CardName.Gold, 30 },

                    // The victory cards.
                    { CardName.Estate, 19 },
                    { CardName.Duchy, 10 },
                    { CardName.Province, 10 },

                    // The kingdom cards.
                    { CardName.Adventurer, 10 },
                    { CardName.CouncilRoom, 10 },
                    { CardName.Festival, 10 },
                    { CardName.Gardens, 10 },
                    { CardName.Laboratory, 10 },
                    { CardName.Moat, 10 },
                    { CardName.Market, 10 },
                    { CardName.Smithy, 10 },
                    { CardName.Village, 10 },
                    { CardName.Woodcutter, 10 },

                    // The curse card
                    { CardName.Curse, 15 }
                };

            CardFactory.SetUpCards(startSupply.Keys);

            gs = new Gamestate.Gamestate(numOfPlayers, startSupply);

            gs.ActivePlayer = gs.Players[0];

            foreach (Player player in gs.Players)
            {
                for (int i = 1; i &lt;= 7; i++)
                {
                    gs.PlayerGainsCard(player, CardName.Copper);
                }

                for (int i = 1; i &lt;= 3; i++)
                {
                    gs.PlayerGainsCard(player, CardName.Estate);
                }

                player.DrawCards(5);
            }

            network.MessageReceived += MessageFromNetwork;

            gui = new GUIInterface();
            gui.EndPhasePressed += EndPhase;
            gui.BuyAttempt += CanBuyCard;
            gui.CardInHandPressed += CanPlayCard;
            gui.StartUpdate += UpdateGui;

            StartTurn();
            gui.RunGame();
        }

        /// &lt;summary&gt;
        /// Updates the GUI with new values.
        /// &lt;/summary&gt;
        /// &lt;author&gt;
        /// Jakob Melnyk (jmel@itu.dk)
        /// &lt;/author&gt;
        private void UpdateGui()
        {
            gui.DrawAction(gs.ActivePlayer.Played.ToArray());
            gui.DrawDiscard(gs.ActivePlayer.DiscardSize != 0 ? gs.ActivePlayer.TopOfDiscard : null);
            gui.DrawHand(gs.Players[(int)clientPlayerNumber - 1].Hand.ToArray());
            gui.DrawDeck(gs.Players[(int)clientPlayerNumber - 1].DeckSize != 0);
            gui.UsedCards(startSupply.Keys.ToArray());
            gui.SetAction((int)gs.NumberOfActions);
            gui.SetBuys((int)gs.NumberOfBuys);
            gui.SetCoins((int)gs.NumberOfCoins);
            gui.SetPlayerNumber((int)clientPlayerNumber);

            switch (gs.GetPhase)
            {
                case 1:
                    gui.SetPhase(0);
                    break;
                case 2:
                    gui.SetPhase(1);
                    break;
            }

            gui.YourTurn(gs.ActivePlayer.PlayerNumber == clientPlayerNumber);
        }

        /// &lt;summary&gt;
        /// Called when game finishes.
        /// &lt;/summary&gt;
        /// &lt;author&gt;
        /// Jakob Melnyk (jmel@itu.dk)
        /// &lt;/author&gt;
        private void EndOfGame()
        {
            List&lt;int&gt; scores = gs.GetScores();
            gui.EndGame(scores.IndexOf(scores.Max()) + 1); // TODO: In case of a draw, lowest numbered player wins.
            Console.WriteLine(&quot;Winner: player: &quot; + scores.IndexOf(scores.Max()) + 1);
            Console.Read();
        }

        #region TurnMethods

        /// &lt;summary&gt;
        /// Starts the turn of the next player.
        /// &lt;/summary&gt;
        /// &lt;author&gt;
        /// Jakob Melnyk (jmel@itu.dk)
        /// &lt;/author&gt;
        private void StartTurn()
        {
            if (gs.ActivePlayer.PlayerNumber == gs.Players.Count)
            {
                gs.ActivePlayer = gs.Players[gs.Players.FindIndex(player =&gt; player.PlayerNumber == 1)];
            }
            else
            {
                gs.ActivePlayer = gs.Players[gs.Players.FindIndex(player =&gt; player.PlayerNumber == gs.ActivePlayer.PlayerNumber + 1)];
            }

            gs.StartActionPhase();

            UpdateGui();
        }

        /// &lt;summary&gt;
        /// Ends the turn of the active player.
        /// &lt;/summary&gt;
        /// &lt;author&gt;
        /// Jakob Melnyk (jmel@itu.dk)
        /// &lt;/author&gt;
        private void EndTurn()
        {
            Contract.Requires(!gs.InActionPhase &amp; !gs.InBuyPhase);

            if (gs.GameOver)
            {
                EndOfGame();
            }
            else
            {
                CleanUp();
                StartTurn();
            }
        }

        /// &lt;summary&gt;
        /// Cleans up the player and other areas.
        /// &lt;/summary&gt;
        /// &lt;author&gt;
        /// Jakob Melnyk (jmel@itu.dk)
        /// &lt;/author&gt;
        private void CleanUp()
        {
            gs.ActivePlayer.CleanUp();
            UpdateGui();
        }

        #endregion

        #region PlayerActions

        /// &lt;summary&gt;
        /// Plays a card from the hand of the player indicated.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;handIndex&quot;&gt;
        /// The index of the card in the hand.
        /// &lt;/param&gt;
        /// &lt;author&gt;
        /// Jakob Melnyk (jmel@itu.dk)
        /// &lt;/author&gt;
        private void CardPlayed(int handIndex)
        {
            Player p = gs.ActivePlayer;
            Card card = p.Hand[handIndex];
            switch (card.Name)
            {
                case CardName.Village:
                    p.DrawCards(1);
                    gs.NumberOfActions += 2;
                    break;

                case CardName.Woodcutter:
                    gs.NumberOfBuys += 1;
                    gs.NumberOfCoins += 2;
                    break;

                case CardName.Smithy:
                    p.DrawCards(3);
                    break;

                case CardName.CouncilRoom:
                    foreach (Player player in gs.Players)
                    {
                        player.DrawCards(1);
                    }

                    p.DrawCards(3);
                    gs.NumberOfBuys += 1;
                    break;

                case CardName.Festival:
                    gs.NumberOfActions += 2;
                    gs.NumberOfBuys += 1;
                    gs.NumberOfCoins += 2;
                    break;

                case CardName.Laboratory:
                    p.DrawCards(2);
                    gs.NumberOfActions += 1;
                    break;

                case CardName.Market:
                    p.DrawCards(1);
                    gs.NumberOfActions += 1;
                    gs.NumberOfBuys += 1;
                    gs.NumberOfCoins += 1;
                    break;

                case CardName.Adventurer:
                    int numberOfTreasures = 0;
                    int temporarySizeAtStart = p.TempZone.Count; // In most cases will be zero.

                    while (numberOfTreasures &lt; 2 &amp; !(p.DeckSize == 0 &amp; p.DiscardSize == 0))
                    {
                        p.MoveFromZoneToTemporary(Zone.Deck);
                        Card c = p.TempZone[p.TempZone.Count - 1];
                        if (c is Treasure)
                        {
                            p.MoveFromTemporaryToZone(c, Zone.Hand);
                            numberOfTreasures++;
                        }
                    }

                    while (p.TempZone.Count &gt; temporarySizeAtStart)
                    {
                        Card c = p.TempZone[p.TempZone.Count - 1];
                        p.MoveFromTemporaryToZone(c, Zone.Discard);
                    }

                    break;

                case CardName.Moat:
                    p.DrawCards(2);
                    break;

                default:
                    throw new ArgumentOutOfRangeException();
            }

            p.MoveFromHandToTemporary(p.Hand[handIndex]);
            p.MoveFromTemporaryToZone(p.TempZone[p.TempZone.Count - 1], Zone.Played);
            gs.NumberOfActions = gs.NumberOfActions - 1;

            UpdateGui();
        }

        /// &lt;summary&gt;
        /// Makes a player buy a card.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;playerNumber&quot;&gt;
        /// The number of the player buying a card.
        /// &lt;/param&gt;
        /// &lt;param name=&quot;cardName&quot;&gt;
        /// The card name to be bought.
        /// &lt;/param&gt;
        /// &lt;author&gt;
        /// Jakob Melnyk (jmel@itu.dk)
        /// &lt;/author&gt;
        private void BuyCard(uint playerNumber, CardName cardName)
        {
            gs.PlayerGainsCard(gs.Players[(int)playerNumber - 1], cardName);

            gs.NumberOfBuys = gs.NumberOfBuys - 1;
            gs.NumberOfCoins = gs.NumberOfCoins - cardCost[cardName];

            UpdateGui();
        }

        #endregion

        #region Delegates

        /// &lt;summary&gt;
        /// Delegate used for messages received from the network.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;message&quot;&gt;
        /// The message received from the server.
        /// &lt;/param&gt;
        /// &lt;param name=&quot;sender&quot;&gt;
        /// The id of the client that sent the message.
        /// &lt;/param&gt;
        /// &lt;author&gt;
        /// Jakob Melnyk (jmel@itu.dk)
        /// &lt;/author&gt;
        private void MessageFromNetwork(string message, int sender)
        {
            if (message.Substring(0, 3).Equals(&quot;!cp&quot;))
            {
                string msg = message.Substring(message.IndexOf(&quot;[&quot;) + 1, message.IndexOf(&quot;]&quot;) - message.IndexOf(&quot;[&quot;) - 1);
                CardPlayed(int.Parse(msg));
            }

            if (message.Substring(0, 3).Equals(&quot;!bc&quot;))
            {
                string msg = message.Substring(message.IndexOf(&quot;[&quot;) + 1, message.IndexOf(&quot;]&quot;) - message.IndexOf(&quot;[&quot;) - 1);
                CardName cardOut;
                if (!CardName.TryParse(msg, out cardOut))
                {
                    throw new Exception(&quot;Could not parse the CardName from server.&quot;);
                }

                BuyCard((uint)sender, cardOut);
            }

            if (message.Substring(0, 3).Equals(&quot;!ep&quot;))
            {
                switch (gs.GetPhase)
                {
                    case 0:
                        break;
                    case 1:
                        gs.EndActionPhase();
                        gs.StartBuyPhase();
                        break;
                    case 2:
                        gs.EndBuyPhase();
                        EndTurn();
                        break;
                }
            }

            UpdateGui();
        }

        /// &lt;summary&gt;
        /// Delegate for BuyAttempt. Checks if it is possible for the player to buy a specific card.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;cardName&quot;&gt;
        /// The name of the card being checked.
        /// &lt;/param&gt;
        /// &lt;author&gt;
        /// Jakob Melnyk (jmel@itu.dk)
        /// &lt;/author&gt;
        private void CanBuyCard(CardName cardName)
        {
            if (gs.ActivePlayer.PlayerNumber == clientPlayerNumber &amp; cardName != CardName.Empty &amp; cardName != CardName.Backside)
            {
                if (gs.NumberOfCoins &gt;= cardCost[cardName] &amp; gs.Supply[cardName] != 0 &amp; gs.NumberOfBuys &gt; 0)
                {
                    network.TurnMessage(&quot;!bc [&quot; + cardName + &quot;]&quot;);
                    BuyCard(clientPlayerNumber, cardName);
                }
            }
        }

        /// &lt;summary&gt;
        /// Delegate for CardInHandPressed. Checks if the card is playable.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;handIndex&quot;&gt;
        /// The index of the card in the hand of the active player.
        /// &lt;/param&gt;
        /// &lt;author&gt;
        /// Jakob Melnyk (jmel@itu.dk)
        /// &lt;/author&gt;
        private void CanPlayCard(int handIndex)
        {
            if (gs.ActivePlayer.PlayerNumber == clientPlayerNumber)
            {
                if (gs.NumberOfActions &gt; 0)
                {
                    Card card = gs.ActivePlayer.Hand[handIndex];

                    if (card is Action)
                    {
                        network.TurnMessage(&quot;!cp [&quot; + handIndex + &quot;]&quot;);
                        CardPlayed(handIndex);
                    }
                }
            }
        }

        /// &lt;summary&gt;
        /// Delegate for the EndPhase button.
        /// &lt;/summary&gt;
        /// &lt;author&gt;
        /// Jakob Melnyk (jmel@itu.dk)
        /// &lt;/author&gt;
        private void EndPhase()
        {
            if (gs.ActivePlayer.PlayerNumber == clientPlayerNumber)
            {
                switch (gs.GetPhase)
                {
                    case 0:
                        break;
                    case 1:
                        gs.EndActionPhase();
                        gs.StartBuyPhase();
                        network.TurnMessage(&quot;!ep&quot;);
                        break;
                    case 2:
                        gs.EndBuyPhase();
                        network.TurnMessage(&quot;!ep&quot;);
                        EndTurn();
                        break;
                }
            }

            UpdateGui();
        }

        #endregion
    }
}</pre></code><script type="text/javascript">
			applyranges('src14', RANGES_14)
		</script>
	</body>
</html>