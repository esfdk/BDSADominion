<html>
	<head>
		<script type="text/javascript" src="../js/coverreport.js">

		</script><script type="text/javascript">
			RANGES_27 = [
  ];
		</script><link rel="stylesheet" type="text/css" href="../css/coverreport.css" />
	</head><body>
		<code id="src27" class="dotCoverSource"><pre>namespace BDSADominion.Gamestate
{
    using System.Collections.Generic;
    using System.Diagnostics.Contracts;
    using System.Linq;

    using BDSADominion.Gamestate.Card_Types;

    /// &lt;summary&gt;
    /// Each player is represented by this object that keeps track of their decks, hands, discard piles, etc.
    /// &lt;/summary&gt;
    /// &lt;author&gt;
    /// Jakob Melnyk (jmel@itu.dk)
    /// &lt;/author&gt;
    public class Player
    {
        #region Fields

        /// &lt;summary&gt;
        /// The deck belonging to the player.
        /// &lt;/summary&gt;
        private readonly Stack&lt;Card&gt; deck = new Stack&lt;Card&gt;();

        /// &lt;summary&gt;
        /// The discard pile of the player.
        /// &lt;/summary&gt;
        private readonly Stack&lt;Card&gt; discard = new Stack&lt;Card&gt;();

        /// &lt;summary&gt;
        /// The cards the player has played this turn.
        /// &lt;/summary&gt;
        private readonly List&lt;Card&gt; played = new List&lt;Card&gt;();

        /// &lt;summary&gt;
        /// The cards in the hand of the player.
        /// &lt;/summary&gt;
        private readonly List&lt;Card&gt; hand = new List&lt;Card&gt;();

        /// &lt;summary&gt;
        /// The cards in the temporary zone.
        /// &lt;/summary&gt;
        private readonly List&lt;Card&gt; temporary = new List&lt;Card&gt;();

        #endregion

        #region Properties

        /// &lt;summary&gt;
        /// Initializes a new instance of the &lt;see cref=&quot;Player&quot;/&gt; class.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;playerNumber&quot;&gt;
        /// The player number.
        /// &lt;/param&gt;
        public Player(uint playerNumber)
        {
            this.PlayerNumber = playerNumber;
            AllCards = new Dictionary&lt;Card, bool&gt;();
        }

        /// &lt;summary&gt;
        /// Gets the Player&#39;s number.
        /// &lt;/summary&gt;
        public uint PlayerNumber { get; private set; }

        /// &lt;summary&gt;
        /// Gets all the cards belonging to the player.
        /// &lt;/summary&gt;
        public Dictionary&lt;Card, bool&gt; AllCards { get; private set; }

        /// &lt;summary&gt;
        /// Gets the size of the deck.
        /// &lt;/summary&gt;
        public uint DeckSize
        {
            get { return (uint)deck.Count; }
        }

        /// &lt;summary&gt;
        /// Gets the size of the discard pile.
        /// &lt;/summary&gt;
        public uint DiscardSize
        {
            get { return (uint)discard.Count; }
        }

        /// &lt;summary&gt;
        /// Gets the card at the top of the discard pile.
        /// &lt;/summary&gt;
        public Card TopOfDiscard
        {
            get
            {
                Contract.Requires(DiscardSize != 0);
                return discard.Peek();
            }
        }

        /// &lt;summary&gt;
        /// Gets the card at the top of the deck.
        /// &lt;/summary&gt;
        public Card TopOfDeck
        {
            get
            {
                Contract.Requires(DeckSize != 0);
                return deck.Peek();
            }
        }

        /// &lt;summary&gt;
        /// Gets the Player&#39;s hand.
        /// &lt;/summary&gt;
        public List&lt;Card&gt; Hand
        {
            get { return hand; }
        }

        /// &lt;summary&gt;
        /// Gets the cards played by the Player.
        /// &lt;/summary&gt;
        public List&lt;Card&gt; Played
        {
            get { return played; }
        }

        /// &lt;summary&gt;
        /// Gets the card in the temporary zone.
        /// &lt;/summary&gt;
        public List&lt;Card&gt; TempZone
        {
            get { return temporary; }
        }
        #endregion

        /// &lt;summary&gt;
        /// Moves a card from the hand to the temporary zone.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;card&quot;&gt;
        /// The card to be moved.
        /// &lt;/param&gt;
        public void MoveFromHandToTemporary(Card card)
        {
            Contract.Requires(Hand.Contains(card));

            Contract.Ensures(!hand.Contains(card));
            Contract.Ensures(TempZone.Contains(card));

            temporary.Add(hand[hand.IndexOf(card)]);
            hand.Remove(card);
        }

        /// &lt;summary&gt;
        /// Moves a card from either the deck or the discard pile into the temporary zone.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;zone&quot;&gt;
        /// The zone to move card from.
        /// &lt;/param&gt;
        public void MoveFromZoneToTemporary(Zone zone)
        {
            Contract.Requires(zone == Zone.Deck | zone == Zone.Discard);

            Contract.Requires(zone == Zone.Deck ? !(DeckSize == 0 &amp; DiscardSize == 0) : true);
            Contract.Requires(zone == Zone.Discard ? DiscardSize != 0 : true);

            Contract.Ensures(TempZone.Count == Contract.OldValue(TempZone.Count) + 1);

            Contract.Ensures(zone == Zone.Deck ? DeckSize == Contract.OldValue(DeckSize) - 1 : true);
            Contract.Ensures(DeckSize != 0 ? TopOfDeck != Contract.OldValue(TopOfDeck) : true);

            Contract.Ensures(zone == Zone.Discard ? DiscardSize == Contract.OldValue(DiscardSize) - 1 : true);
            Contract.Ensures(DiscardSize != 0 ? TopOfDiscard != Contract.OldValue(TopOfDiscard) : true);

            switch (zone)
            {
                case Zone.Deck:
                    if (DeckSize == 0)
                    {
                        ShuffleDiscard();
                    }

                    temporary.Add(deck.Pop());
                    break;
                case Zone.Discard:
                    if (DiscardSize == 0)
                    {
                        break;
                    }

                    temporary.Add(discard.Pop());
                    break;
            }
        }

        /// &lt;summary&gt;
        /// Move a card from the temporary zone to another zone.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;card&quot;&gt;
        /// The card to move from the temporary zone.
        /// &lt;/param&gt;
        /// &lt;param name=&quot;zone&quot;&gt;
        /// The zone to move the card to.
        /// &lt;/param&gt;
        public void MoveFromTemporaryToZone(Card card, Zone zone)
        {
            Contract.Requires(zone == Zone.Deck | zone == Zone.Discard | zone == Zone.Hand | zone == Zone.Played);
            Contract.Requires(TempZone.Contains(card));

            Contract.Ensures(TempZone.Count == Contract.OldValue(TempZone.Count) - 1);

            Contract.Ensures(zone == Zone.Deck ? DeckSize == Contract.OldValue(DeckSize) + 1 : true);
            Contract.Ensures(zone == Zone.Deck ? TopOfDeck == Contract.OldValue(TempZone[TempZone.Count - 1]) : true);

            Contract.Ensures(zone == Zone.Discard ? DiscardSize == Contract.OldValue(DiscardSize) + 1 : true);
            Contract.Ensures(zone == Zone.Discard ? TopOfDiscard == Contract.OldValue(TempZone[TempZone.Count - 1]) : true);

            Contract.Ensures(zone == Zone.Hand ? (Hand.Count == Contract.OldValue(Hand.Count) + 1) &amp; Hand.Contains(card) : true);
            Contract.Ensures(zone == Zone.Hand ? Hand[Hand.Count - 1] == Contract.OldValue(TempZone[TempZone.Count - 1]) : true);

            Contract.Ensures(zone == Zone.Played ? (Played.Count == Contract.OldValue(Played.Count) + 1) &amp; Played.Contains(card) : true);
            Contract.Ensures(zone == Zone.Played ? Played[Played.Count - 1] == Contract.OldValue(TempZone[TempZone.Count - 1]) : true);

            switch (zone)
            {
                case Zone.Deck:
                    temporary.Remove(card);
                    deck.Push(card);
                    break;
                case Zone.Discard:
                    temporary.Remove(card);
                    discard.Push(card);
                    break;
                case Zone.Hand:
                    temporary.Remove(card);
                    hand.Add(card);
                    break;
                case Zone.Played:
                    temporary.Remove(card);
                    played.Add(card);
                    break;
            }
        }

        /// &lt;summary&gt;
        /// Adds a card to a player&#39;s hand.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;card&quot;&gt;
        /// The card to be added to the zone.
        /// &lt;/param&gt;
        /// &lt;param name=&quot;zone&quot;&gt;
        /// The zone to add the card to.
        /// &lt;/param&gt;
        public void AddCardToZone(Card card, Zone zone)
        {
            Contract.Requires(zone == Zone.Deck | zone == Zone.Discard | zone == Zone.Hand | zone == Zone.Played);

            Contract.Ensures(AllCards[card]);

            Contract.Ensures(zone == Zone.Hand ? Hand[Hand.Count - 1] == card : true);
            Contract.Ensures(zone == Zone.Hand ? hand.Count == Contract.OldValue(hand.Count) + 1 : true);

            Contract.Ensures(zone == Zone.Played ? Played[Played.Count - 1] == card : true);
            Contract.Ensures(zone == Zone.Played ? played.Count == Contract.OldValue(played.Count) + 1 : true);

            Contract.Ensures(zone == Zone.Deck ? TopOfDeck == card : true);
            Contract.Ensures(zone == Zone.Deck ? DeckSize == Contract.OldValue(DeckSize) + 1 : true);

            Contract.Ensures(zone == Zone.Discard ? TopOfDiscard == card : true);
            Contract.Ensures(zone == Zone.Discard ? DiscardSize == Contract.OldValue(DiscardSize) + 1 : true);

            AllCards.Add(card, true);

            switch (zone)
            {
                case Zone.Deck:
                    deck.Push(card);
                    break;
                case Zone.Discard:
                    discard.Push(card);
                    break;
                case Zone.Hand:
                    hand.Add(card);
                    break;
                case Zone.Played:
                    played.Add(card);
                    break;
            }
        }

        /// &lt;summary&gt;
        /// Removes a card from the player.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;card&quot;&gt;
        /// The card to be removed.
        /// &lt;/param&gt;
        /// &lt;param name=&quot;zone&quot;&gt;
        /// The zone the card is currently in.
        /// &lt;/param&gt;
        public void RemoveCardFromZone(Card card, Zone zone)
        {
            Contract.Requires(zone == Zone.Deck | zone == Zone.Discard | zone == Zone.Hand | zone == Zone.Played);
            Contract.Requires(AllCards.ContainsKey(card));

            Contract.Requires(zone == Zone.Hand ? Hand.Contains(card) : true);
            Contract.Requires(zone == Zone.Played ? Played.Contains(card) : true);
            Contract.Requires(zone == Zone.Deck ? !(DeckSize == 0 &amp; DiscardSize == 0) : true);
            Contract.Requires(zone == Zone.Discard ? DiscardSize != 0 : true);

            Contract.Ensures(!AllCards.ContainsKey(card));

            Contract.Ensures(zone == Zone.Hand ? !Hand.Contains(card) : true);
            Contract.Ensures(zone == Zone.Hand ? Hand.Count == Contract.OldValue(hand.Count) - 1 : true);

            Contract.Ensures(zone == Zone.Played ? !Played.Contains(card) : true);
            Contract.Ensures(zone == Zone.Played ? Played.Count == Contract.OldValue(played.Count) - 1 : true);

            Contract.Ensures(zone == Zone.Deck ? DeckSize == Contract.OldValue(DeckSize) - 1 : true);
            Contract.Ensures(zone == Zone.Discard ? DiscardSize == Contract.OldValue(DiscardSize) - 1 : true);

            switch (zone)
            {
                case Zone.Deck:
                    AllCards.Remove(deck.Peek());
                    deck.Pop();
                    break;
                case Zone.Discard:
                    AllCards.Remove(discard.Peek());
                    discard.Pop();
                    break;
                case Zone.Hand:
                    AllCards.Remove(card);
                    hand.Remove(card);
                    break;
                case Zone.Played:
                    AllCards.Remove(card);
                    played.Remove(card);
                    break;
            }
        }

        /// &lt;summary&gt;
        /// Makes the player draw a specific amount of cards.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;amount&quot;&gt;
        /// The amount of cards to be drawn.
        /// &lt;/param&gt;
        public void DrawCards(uint amount)
        {
            for (int i = 1; i &lt;= amount; i++)
            {
                if (DeckSize + DiscardSize &lt; 1)
                {
                    break;
                }

                DrawCard();
            }
        }

        /// &lt;summary&gt;
        /// Makes the player draw a card from his deck. The player will shuffle the discard pile into the deck if necessary.
        /// &lt;/summary&gt;
        public void DrawCard()
        {
            Contract.Requires(DeckSize + DiscardSize != 0);

            Contract.Ensures(Hand.Count == Contract.OldValue(Hand.Count) + 1);
            if (DeckSize == 0)
            {
                ShuffleDiscard();
            }

            hand.Add(deck.Pop());
        }

        /// &lt;summary&gt;
        /// Takes all the cards in the players hand and in the played zone, and puts them in the discard pile. Then draws five cards.
        /// &lt;/summary&gt;
        public void CleanUp()
        {
            foreach (Card card in hand)
            {
                discard.Push(card);
            }

            hand.Clear();

            foreach (Card card in played)
            {
                discard.Push(card);
            }

            played.Clear();

            DrawCards(5);
        }

        /// &lt;summary&gt;
        /// A card cannot be in the DECK, DISCARD, HAND or PLAYED zones of a player 
        /// if it is not in the &#39;ALL CARDS&#39;.
        /// &lt;/summary&gt;
        [ContractInvariantMethod]
        private void ObjectInvariant()
        {
            Contract.Invariant(InvariantHelper());
        }

        /// &lt;summary&gt;
        /// Helper method for the object invariant.
        /// &lt;/summary&gt;
        /// &lt;returns&gt;
        /// True, if invariant holds. False, if not.
        /// &lt;/returns&gt;
        private bool InvariantHelper()
        {
            foreach (Card card in AllCards.Keys)
            {
                if (!deck.Contains(card) &amp; !discard.Contains(card) &amp; !played.Contains(card) &amp; !hand.Contains(card) &amp; !temporary.Contains(card))
                {
                    return false;
                }
            }

            if (deck.Any(card =&gt; !AllCards.ContainsKey(card)))
            {
                return false;
            }

            if (discard.Any(card =&gt; !AllCards.ContainsKey(card)))
            {
                return false;
            }

            if (played.Any(card =&gt; !AllCards.ContainsKey(card)))
            {
                return false;
            }

            if (hand.Any(card =&gt; !AllCards.ContainsKey(card)))
            {
                return false;
            }

            if (temporary.Any(card =&gt; !AllCards.ContainsKey(card)))
            {
                return false;
            }

            return true;
        }

        /// &lt;summary&gt;
        /// Shuffles the discard pile into the deck.
        /// &lt;/summary&gt;
        private void ShuffleDiscard()
        {
            Contract.Requires(DeckSize == 0);
            Contract.Requires(DiscardSize != 0);

            Contract.Ensures(DeckSize != 0);
            Contract.Ensures(DiscardSize == 0);

            Stack&lt;Card&gt; a = new Stack&lt;Card&gt;();
            Stack&lt;Card&gt; b = new Stack&lt;Card&gt;();
            Stack&lt;Card&gt; c = new Stack&lt;Card&gt;();
            Stack&lt;Card&gt; d = new Stack&lt;Card&gt;();

            while (DiscardSize &gt;= 4)
            {
                a.Push(discard.Pop());
                b.Push(discard.Pop());
                c.Push(discard.Pop());
                d.Push(discard.Pop());
            }

            if (DiscardSize &gt;= 1)
            {
                if (DiscardSize &gt;= 2)
                {
                    if (DiscardSize &gt;= 3)
                    {
                        c.Push(discard.Pop());
                    }

                    b.Push(discard.Pop());
                }

                a.Push(discard.Pop());
            }

            Stack&lt;Card&gt; temp = new Stack&lt;Card&gt;();

            while (a.Count != 0)
            {
                temp.Push(a.Pop());
            }

            while (b.Count != 0)
            {
                temp.Push(b.Pop());
            }

            while (c.Count != 0)
            {
                temp.Push(c.Pop());
            }

            while (d.Count != 0)
            {
                temp.Push(d.Pop());
            }

            while (temp.Count != 0)
            {
                deck.Push(temp.Pop());
            }


            // Following code makes the pseudo-shuffling random, but would force us to send the deck each time it is shuffled, due to its pseudo-random nature.
            /*
            Random r = new Random();
            List&lt;Card&gt; cards = discard.ToList();

            for (int i = 0; i &lt; cards.Count; i++)
            {
                int index = r.Next(cards.Count);
                Card c = cards[i];
                cards[i] = cards[index];
                cards[index] = c;
            }

            discard.Clear();

            foreach (Card card in cards)
            {
                deck.Push(card);
            }*/
        }
    }
}</pre></code><script type="text/javascript">
			applyranges('src27', RANGES_27)
		</script>
	</body>
</html>