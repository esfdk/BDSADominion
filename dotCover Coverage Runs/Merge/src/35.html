<html>
	<head>
		<script type="text/javascript" src="../js/coverreport.js">

		</script><script type="text/javascript">
			RANGES_35 = [
  ];
		</script><link rel="stylesheet" type="text/css" href="../css/coverreport.css" />
	</head><body>
		<code id="src35" class="dotCoverSource"><pre>namespace BDSADominion
{
    using System;
    using System.Collections.Generic;
    using System.Diagnostics.Contracts;
    using System.Linq;
    using System.Net;
    using BDSADominion.Gamestate;
    using BDSADominion.Gamestate.Card_Types;
    using BDSADominion.GUI;
    using BDSADominion.Networking;
    using Action = BDSADominion.Gamestate.Card_Types.Action;

    /// &lt;summary&gt;
    /// The main class of the game. Contains the network, GUI, gamestate and logic.
    /// &lt;/summary&gt;
    public class Control
    {
        #region Fields

        #region CardCost

        /// &lt;summary&gt;
        /// Used to determine costs of cards.
        /// &lt;/summary&gt;
        private readonly Dictionary&lt;CardName, uint&gt; cardCost = new Dictionary&lt;CardName, uint&gt;
            {
                // The treasure cards.
                { CardName.Copper, 0 },
                { CardName.Silver, 3 },
                { CardName.Gold, 6 },
                
                // The victory cards.
                { CardName.Curse, 0 },
                { CardName.Estate, 2 },
                { CardName.Duchy, 5 },
                { CardName.Province, 8 },

                // The kingdom cards.
                // Cost : 2
                { CardName.Moat, 2 },

                // Cost : 3
                { CardName.Village, 3 },
                { CardName.Woodcutter, 3 },
                
                // Cost : 4
                { CardName.Gardens, 4 },
                { CardName.Smithy, 4 },
                
                // Cost : 5
                { CardName.CouncilRoom, 5 },
                { CardName.Laboratory, 5 },
                { CardName.Festival, 5 },
                { CardName.Market, 5 },
                
                // Cost : 6
                { CardName.Adventurer, 6 }
            };

        #endregion

        /// &lt;summary&gt;
        /// The gui used by this client.
        /// &lt;/summary&gt;
        private GUIInterface gui;

        /// &lt;summary&gt;
        /// Object used to create the gamestate.
        /// &lt;/summary&gt;
        /// &lt;author&gt;
        /// Jakob Melnyk (jmel@itu.dk)
        /// &lt;/author&gt;
        private Dictionary&lt;CardName, uint&gt; startSupply;

        private bool serverStarted = false;

        private int numberOfPlayers;

        /// &lt;summary&gt;
        /// The interface for communicating with the network
        /// &lt;/summary&gt;
        private NetworkingInterface network;

        /// &lt;summary&gt;
        /// The gamestate used for this game.
        /// &lt;/summary&gt;
        /// &lt;author&gt;
        /// Jakob Melnyk (jmel@itu.dk)
        /// &lt;/author&gt;
        private Gamestate.Gamestate gs;

        /// &lt;summary&gt;
        /// The player number of this client.
        /// &lt;/summary&gt;
        private uint clientPlayerNumber;

        #endregion

        /// &lt;summary&gt;
        /// Initializes a new instance of the &lt;see cref=&quot;Control&quot;/&gt; class.
        /// &lt;/summary&gt;
        /// &lt;author&gt;
        /// Christian &#39;Troy&#39; Jensen (chrj@itu.dk)
        /// &lt;/author&gt;
        public Control()
        {
            StartNetwork(clientType());

            network.MessageReceived += ReceivePreGameMessage;

            while (!serverStarted)
            {
                string input = Console.ReadLine();

                network.PreGameMessage(input);
            }
        }

        /// &lt;summary&gt;
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;host&quot;&gt;
        /// The host.
        /// &lt;/param&gt;
        /// &lt;author&gt;
        /// Christian &#39;Troy&#39; Jensen (chrj@itu.dk)
        /// &lt;/author&gt;
        private void StartNetwork(bool host)
        {
            if (host)
            {
                Console.WriteLine(&quot;Host Started&quot;);
                network = new NetworkingInterface();
                Console.WriteLine(network.GetServerIp());
            }
            else
            {
                IPAddress ipAddress = null;

                bool parseSuccess = false;

                while (!parseSuccess)
                {
                    Console.WriteLine(&quot;Please input IP for server:&quot;);
                    string ip = Console.ReadLine();

                    parseSuccess = IPAddress.TryParse(ip, out ipAddress);
                    if (!parseSuccess)
                    {
                        Console.WriteLine(&quot;IP not valid, try again:&quot;);
                    }
                }

                network = new NetworkingInterface(ipAddress);
                Console.WriteLine(&quot;Client started&quot;);
            }
        }

        /// &lt;summary&gt;
        /// &lt;/summary&gt;
        /// &lt;returns&gt;
        /// &lt;/returns&gt;
        /// &lt;author&gt;
        /// Christian &#39;Troy&#39; Jensen (chrj@itu.dk)
        /// &lt;/author&gt;
        private bool clientType()
        {
            bool host = false;
            string input = null;

            while (input == null)
            {
                Console.WriteLine(&quot;Please select server or client:&quot;);

                input = Console.ReadLine();

                if (input.Equals(&quot;client&quot;))
                {
                    host = false;
                }
                else if (input.Equals(&quot;server&quot;))
                {
                    host = true;
                }
                else
                {
                    Console.WriteLine(&quot;Unrecognized input&quot;);
                    input = null;
                }
            }

            return host;
        }

        /// &lt;summary&gt;
        /// used to recieve messages before the game starts
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;message&quot;&gt;
        /// The message that is being passed. Clean
        /// &lt;/param&gt;
        /// &lt;param name=&quot;playerId&quot;&gt;
        /// The Id of the player that sent it.
        /// &lt;/param&gt;
        /// &lt;author&gt;
        /// Christian Jensen (chrj@itu.dk)
        /// &lt;/author&gt;
        private void ReceivePreGameMessage(string message, int playerId)
        {
            if (playerId == 0 &amp; message.Contains(&quot;&lt;STGM&gt;&quot;))
            {
                string[] messageParts = message.Split(new[] { &#39;,&#39; });
                serverStarted = true;
                clientPlayerNumber = uint.Parse(messageParts[2]);
                network.SetResponseList(int.Parse(messageParts[1]));
                numberOfPlayers = int.Parse(messageParts[1]);
                Console.WriteLine(
                    &quot;SYSTEM: GAME STARTED. There are {1} players and you are player {0}&quot;,
                    clientPlayerNumber,
                    numberOfPlayers);
                network.MessageReceived -= ReceivePreGameMessage;
                SetUpGame((uint)numberOfPlayers);
            }
        }

        /// &lt;summary&gt;
        /// Sets up a new game with the number of players pass as parameter.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;numOfPlayers&quot;&gt;
        /// The number Of Players.
        /// &lt;/param&gt;
        /// &lt;author&gt;
        /// Jakob Melnyk (jmel@itu.dk)
        /// &lt;/author&gt;
        private void SetUpGame(uint numOfPlayers)
        {
            startSupply = new Dictionary&lt;CardName, uint&gt;
                {
                    // The treasure cards.
                    { CardName.Copper, 51 },
                    { CardName.Silver, 30 },
                    { CardName.Gold, 30 },

                    // The victory cards.
                    { CardName.Estate, 19 },
                    { CardName.Duchy, 10 },
                    { CardName.Province, 10 },

                    // The kingdom cards.
                    { CardName.Adventurer, 10 },
                    { CardName.CouncilRoom, 10 },
                    { CardName.Festival, 10 },
                    { CardName.Gardens, 10 },
                    { CardName.Laboratory, 10 },
                    { CardName.Moat, 10 },
                    { CardName.Market, 10 },
                    { CardName.Smithy, 10 },
                    { CardName.Village, 10 },
                    { CardName.Woodcutter, 10 },

                    // The curse card
                    { CardName.Curse, 15 }
                };

            CardFactory.SetUpCards(startSupply.Keys);

            gs = new Gamestate.Gamestate(numOfPlayers, startSupply);

            gs.ActivePlayer = gs.Players[0];

            foreach (Player player in gs.Players)
            {
                for (int i = 1; i &lt;= 7; i++)
                {
                    gs.PlayerGainsCard(player, CardName.Copper);
                }

                for (int i = 1; i &lt;= 3; i++)
                {
                    gs.PlayerGainsCard(player, CardName.Estate);
                }

                player.DrawCards(5);
            }

            network.MessageReceived += MessageFromNetwork;

            gui = new GUIInterface();
            gui.EndPhasePressed += EndPhase;
            gui.BuyAttempt += CanBuyCard;
            gui.CardInHandPressed += CanPlayCard;
            gui.StartUpdate += UpdateGui;

            StartTurn();
            gui.RunGame();
        }

        /// &lt;summary&gt;
        /// Updates the GUI with new values.
        /// &lt;/summary&gt;
        /// &lt;author&gt;
        /// Jakob Melnyk (jmel@itu.dk)
        /// &lt;/author&gt;
        private void UpdateGui()
        {
            gui.DrawAction(gs.ActivePlayer.Played.ToArray());
            gui.DrawDiscard(gs.ActivePlayer.DiscardSize != 0 ? gs.ActivePlayer.TopOfDiscard : null);
            gui.DrawHand(gs.Players[(int)clientPlayerNumber - 1].Hand.ToArray());
            gui.DrawDeck(gs.Players[(int)clientPlayerNumber - 1].DeckSize != 0);
            gui.UsedCards(startSupply.Keys.ToArray());
            gui.SetAction((int)gs.NumberOfActions);
            gui.SetBuys((int)gs.NumberOfBuys);
            gui.SetCoins((int)gs.NumberOfCoins);
            gui.SetPlayerNumber((int)clientPlayerNumber);

            switch (gs.GetPhase)
            {
                case 1:
                    gui.SetPhase(0);
                    break;
                case 2:
                    gui.SetPhase(1);
                    break;
            }

            gui.YourTurn(gs.ActivePlayer.PlayerNumber == clientPlayerNumber);
        }

        /// &lt;summary&gt;
        /// Called when game finishes.
        /// &lt;/summary&gt;
        /// &lt;author&gt;
        /// Jakob Melnyk (jmel@itu.dk)
        /// &lt;/author&gt;
        private void EndOfGame()
        {
            List&lt;int&gt; scores = gs.GetScores();
            gui.EndGame(scores.IndexOf(scores.Max()) + 1); // TODO: In case of a draw, lowest numbered player wins.
            Console.WriteLine(&quot;Winner: player: &quot; + scores.IndexOf(scores.Max()) + 1);
            Console.Read();
        }

        #region TurnMethods

        /// &lt;summary&gt;
        /// Starts the turn of the next player.
        /// &lt;/summary&gt;
        /// &lt;author&gt;
        /// Jakob Melnyk (jmel@itu.dk)
        /// &lt;/author&gt;
        private void StartTurn()
        {
            if (gs.ActivePlayer.PlayerNumber == gs.Players.Count)
            {
                gs.ActivePlayer = gs.Players[gs.Players.FindIndex(player =&gt; player.PlayerNumber == 1)];
            }
            else
            {
                gs.ActivePlayer = gs.Players[gs.Players.FindIndex(player =&gt; player.PlayerNumber == gs.ActivePlayer.PlayerNumber + 1)];
            }

            gs.StartActionPhase();

            UpdateGui();
        }

        /// &lt;summary&gt;
        /// Ends the turn of the active player.
        /// &lt;/summary&gt;
        /// &lt;author&gt;
        /// Jakob Melnyk (jmel@itu.dk)
        /// &lt;/author&gt;
        private void EndTurn()
        {
            Contract.Requires(!gs.InActionPhase &amp; !gs.InBuyPhase);

            if (gs.GameOver)
            {
                EndOfGame();
            }
            else
            {
                CleanUp();
                StartTurn();
            }
        }

        /// &lt;summary&gt;
        /// Cleans up the player and other areas.
        /// &lt;/summary&gt;
        /// &lt;author&gt;
        /// Jakob Melnyk (jmel@itu.dk)
        /// &lt;/author&gt;
        private void CleanUp()
        {
            gs.ActivePlayer.CleanUp();
            UpdateGui();
        }

        #endregion

        #region PlayerActions

        /// &lt;summary&gt;
        /// Plays a card from the hand of the player indicated.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;handIndex&quot;&gt;
        /// The index of the card in the hand.
        /// &lt;/param&gt;
        /// &lt;author&gt;
        /// Jakob Melnyk (jmel@itu.dk)
        /// &lt;/author&gt;
        private void CardPlayed(int handIndex)
        {
            Player p = gs.ActivePlayer;
            Card card = p.Hand[handIndex];
            switch (card.Name)
            {
                case CardName.Village:
                    p.DrawCards(1);
                    gs.NumberOfActions += 2;
                    break;

                case CardName.Woodcutter:
                    gs.NumberOfBuys += 1;
                    gs.NumberOfCoins += 2;
                    break;

                case CardName.Smithy:
                    p.DrawCards(3);
                    break;

                case CardName.CouncilRoom:
                    foreach (Player player in gs.Players)
                    {
                        player.DrawCards(1);
                    }

                    p.DrawCards(3);
                    gs.NumberOfBuys += 1;
                    break;

                case CardName.Festival:
                    gs.NumberOfActions += 2;
                    gs.NumberOfBuys += 1;
                    gs.NumberOfCoins += 2;
                    break;

                case CardName.Laboratory:
                    p.DrawCards(2);
                    gs.NumberOfActions += 1;
                    break;

                case CardName.Market:
                    p.DrawCards(1);
                    gs.NumberOfActions += 1;
                    gs.NumberOfBuys += 1;
                    gs.NumberOfCoins += 1;
                    break;

                case CardName.Adventurer:
                    int numberOfTreasures = 0;
                    int temporarySizeAtStart = p.TempZone.Count; // In most cases will be zero.

                    while (numberOfTreasures &lt; 2 &amp; !(p.DeckSize == 0 &amp; p.DiscardSize == 0))
                    {
                        p.MoveFromZoneToTemporary(Zone.Deck);
                        Card c = p.TempZone[p.TempZone.Count - 1];
                        if (c is Treasure)
                        {
                            p.MoveFromTemporaryToZone(c, Zone.Hand);
                            numberOfTreasures++;
                        }
                    }

                    while (p.TempZone.Count &gt; temporarySizeAtStart)
                    {
                        Card c = p.TempZone[p.TempZone.Count - 1];
                        p.MoveFromTemporaryToZone(c, Zone.Discard);
                    }

                    break;

                case CardName.Moat:
                    p.DrawCards(2);
                    break;

                default:
                    throw new ArgumentOutOfRangeException();
            }

            p.MoveFromHandToTemporary(p.Hand[handIndex]);
            p.MoveFromTemporaryToZone(p.TempZone[p.TempZone.Count - 1], Zone.Played);
            gs.NumberOfActions = gs.NumberOfActions - 1;

            UpdateGui();
        }

        /// &lt;summary&gt;
        /// Makes a player buy a card.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;playerNumber&quot;&gt;
        /// The number of the player buying a card.
        /// &lt;/param&gt;
        /// &lt;param name=&quot;cardName&quot;&gt;
        /// The card name to be bought.
        /// &lt;/param&gt;
        /// &lt;author&gt;
        /// Jakob Melnyk (jmel@itu.dk)
        /// &lt;/author&gt;
        private void BuyCard(uint playerNumber, CardName cardName)
        {
            gs.PlayerGainsCard(gs.Players[(int)playerNumber - 1], cardName);

            gs.NumberOfBuys = gs.NumberOfBuys - 1;
            gs.NumberOfCoins = gs.NumberOfCoins - cardCost[cardName];

            UpdateGui();
        }

        #endregion

        #region Delegates

        /// &lt;summary&gt;
        /// Delegate used for messages received from the network.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;message&quot;&gt;
        /// The message received from the server.
        /// &lt;/param&gt;
        /// &lt;param name=&quot;sender&quot;&gt;
        /// The id of the client that sent the message.
        /// &lt;/param&gt;
        /// &lt;author&gt;
        /// Jakob Melnyk (jmel@itu.dk)
        /// &lt;/author&gt;
        private void MessageFromNetwork(string message, int sender)
        {
            if (message.Substring(0, 3).Equals(&quot;!cp&quot;))
            {
                string msg = message.Substring(message.IndexOf(&quot;[&quot;) + 1, message.IndexOf(&quot;]&quot;) - message.IndexOf(&quot;[&quot;) - 1);
                CardPlayed(int.Parse(msg));
            }

            if (message.Substring(0, 3).Equals(&quot;!bc&quot;))
            {
                string msg = message.Substring(message.IndexOf(&quot;[&quot;) + 1, message.IndexOf(&quot;]&quot;) - message.IndexOf(&quot;[&quot;) - 1);
                CardName cardOut;
                if (!CardName.TryParse(msg, out cardOut))
                {
                    throw new Exception(&quot;Could not parse the CardName from server.&quot;);
                }

                BuyCard((uint)sender, cardOut);
            }

            if (message.Substring(0, 3).Equals(&quot;!ep&quot;))
            {
                switch (gs.GetPhase)
                {
                    case 0:
                        break;
                    case 1:
                        gs.EndActionPhase();
                        gs.StartBuyPhase();
                        break;
                    case 2:
                        gs.EndBuyPhase();
                        EndTurn();
                        break;
                }
            }

            UpdateGui();
        }

        /// &lt;summary&gt;
        /// Delegate for BuyAttempt. Checks if it is possible for the player to buy a specific card.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;cardName&quot;&gt;
        /// The name of the card being checked.
        /// &lt;/param&gt;
        /// &lt;author&gt;
        /// Jakob Melnyk (jmel@itu.dk)
        /// &lt;/author&gt;
        private void CanBuyCard(CardName cardName)
        {
            if (gs.ActivePlayer.PlayerNumber == clientPlayerNumber &amp; cardName != CardName.Empty &amp; cardName != CardName.Backside)
            {
                if (gs.NumberOfCoins &gt;= cardCost[cardName] &amp; gs.Supply[cardName] != 0 &amp; gs.NumberOfBuys &gt; 0)
                {
                    network.TurnMessage(&quot;!bc [&quot; + cardName + &quot;]&quot;);
                    BuyCard(clientPlayerNumber, cardName);
                }
            }
        }

        /// &lt;summary&gt;
        /// Delegate for CardInHandPressed. Checks if the card is playable.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;handIndex&quot;&gt;
        /// The index of the card in the hand of the active player.
        /// &lt;/param&gt;
        /// &lt;author&gt;
        /// Jakob Melnyk (jmel@itu.dk)
        /// &lt;/author&gt;
        private void CanPlayCard(int handIndex)
        {
            if (gs.ActivePlayer.PlayerNumber == clientPlayerNumber)
            {
                if (gs.NumberOfActions &gt; 0)
                {
                    Card card = gs.ActivePlayer.Hand[handIndex];

                    if (card is Action)
                    {
                        network.TurnMessage(&quot;!cp [&quot; + handIndex + &quot;]&quot;);
                        CardPlayed(handIndex);
                    }
                }
            }
        }

        /// &lt;summary&gt;
        /// Delegate for the EndPhase button.
        /// &lt;/summary&gt;
        /// &lt;author&gt;
        /// Jakob Melnyk (jmel@itu.dk)
        /// &lt;/author&gt;
        private void EndPhase()
        {
            if (gs.ActivePlayer.PlayerNumber == clientPlayerNumber)
            {
                switch (gs.GetPhase)
                {
                    case 0:
                        break;
                    case 1:
                        gs.EndActionPhase();
                        gs.StartBuyPhase();
                        network.TurnMessage(&quot;!ep&quot;);
                        break;
                    case 2:
                        gs.EndBuyPhase();
                        network.TurnMessage(&quot;!ep&quot;);
                        EndTurn();
                        break;
                }
            }

            UpdateGui();
        }

        #endregion
    }
}</pre></code><script type="text/javascript">
			applyranges('src35', RANGES_35)
		</script>
	</body>
</html>